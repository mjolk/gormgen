{{define "driver"}}// DON'T EDIT *** generated by ormgen *** DON'T EDIT //
package {{.PackageName}}

import (
	"context"
	"database/sql"
	"fmt"
	"log"
	"time"

	uuid "github.com/gofrs/uuid"
	_ "github.com/lib/pq" //import pq driver
	"gitlab.com/astrotit/registration-api/net"
)

type dbConfig struct {
	Host     string
	Db       string
	Dbuser   string
	Password string
}

/*func (cfg dbConfig) Connect(ctx context.Context) (sql.Conn, error) {
	return , nil
}*/

// SQLContext context for sql operations
type SQLContext interface {
	WithTx(tx *sql.Tx) SQLContext
	WithDeadline(t time.Time) (SQLContext, context.CancelFunc)
	Exec(query string, args ...interface{}) (sql.Result, error)
	Query(query string, args ...interface{}) (*sql.Rows, error)
	QueryRow(query string, args ...interface{}) *sql.Row
	TxOptions() *sql.TxOptions
	TxID() uuid.UUID
	context.Context
}

type dbHandle interface {
	ExecContext(
		c context.Context,
		query string,
		args ...interface{},
	) (sql.Result, error)
	QueryContext(
		c context.Context,
		query string,
		args ...interface{},
	) (*sql.Rows, error)
	QueryRowContext(
		c context.Context,
		query string,
		args ...interface{},
	) *sql.Row
}

type sqlContext struct {
	txID      uuid.UUID
	tx        *sql.Tx
	isolation string
	context.Context
	txOptions *sql.TxOptions
}

func (c sqlContext) ctx() dbHandle {
	if c.tx != nil {
		return c.tx
	}
	return Dbase()
}

func (c sqlContext) WithTx(tx *sql.Tx) SQLContext {
	return sqlContext{
		tx:        tx,
		Context:   c.Context,
		txOptions: c.txOptions,
		txID:      c.txID,
	}
}

func (c sqlContext) WithDeadline(d time.Time) (SQLContext, context.CancelFunc) {
	ctx, cancel := context.WithDeadline(c.Context, d)
	return sqlContext{
		tx:        c.tx,
		Context:   ctx,
		txOptions: c.txOptions,
	}, cancel
}

func (c sqlContext) TxID() uuid.UUID {
	return c.txID
}

func (c sqlContext) TxOptions() *sql.TxOptions {
	return c.txOptions
}

// NewSQLContext new sql context
func NewSQLContext(ctx context.Context) SQLContext {
	return sqlContext{
		Context: ctx,
		txOptions: &sql.TxOptions{
			Isolation: sql.LevelSerializable,
			ReadOnly:  false,
		},
		txID: uuid.Must(uuid.NewV1()),
	}
}

// NewTxSQLContext new sql context with custom transaction options
func NewTxSQLContext(ctx context.Context, to *sql.TxOptions) SQLContext {
	return sqlContext{
		Context:   ctx,
		txOptions: to,
	}
}

func (c sqlContext) Exec(query string, args ...interface{}) (sql.Result, error) {
	return c.ctx().ExecContext(c, query, args...)
}

func (c sqlContext) Query(query string, args ...interface{}) (*sql.Rows, error) {
	return c.ctx().QueryContext(c, query, args...)
}

func (c sqlContext) QueryRow(query string, args ...interface{}) *sql.Row {
	return c.ctx().QueryRowContext(c, query, args...)
}

var dbio *sql.DB

// Dbase database io handle
func Dbase() *sql.DB {
	if dbio == nil {
		cfg := loadConfig()
		openConnection(cfg)
	}
	return dbio
}

func openConnection(dbconfig dbConfig) {
	log.Printf(
		"user=%s dbname=%s host=%s sslmode=disable",
		dbconfig.Dbuser,
		dbconfig.Db,
		dbconfig.Host,
	)
	var err error
	dbio, err = sql.Open(
		"postgres",
		fmt.Sprintf(
			"postgres://%s:%s@%s/%s?sslmode=disable",
			dbconfig.Dbuser,
			dbconfig.Password,
			dbconfig.Host,
			dbconfig.Db,
		),
	)
	if err != nil {
		log.Fatalf("error connecting to database :\n%s\n", err)
	}
}

// Transact execute ops in transaction
func Transact(ctx SQLContext, txFunc func(SQLContext) error) (err error) {
	var tx *sql.Tx
	tx, err = Dbase().BeginTx(ctx, ctx.TxOptions())
	if err != nil {
		return
	}
	ctx = ctx.WithTx(tx)
	defer func() {
		if p := recover(); p != nil {
			switch p := p.(type) {
			case error:
				err = p
			default:
				err = fmt.Errorf("%s", p)
			}
		}
		if err != nil {
			tx.Rollback()
			return
		}
		err = tx.Commit()
	}()
	return txFunc(ctx)
}

func loadConfig() dbConfig {
	cfg := dbConfig{}
	cfg.Host = net.ConfigValue("DBHOST")
	cfg.Dbuser = net.ConfigValue("DBUSER")
	cfg.Password = net.ConfigValue("DBPASSWORD")
	cfg.Db = net.ConfigValue("DB")
	return cfg
}
