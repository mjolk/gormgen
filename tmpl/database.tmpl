{{define "driver"}}// DON'T EDIT *** generated by ormgen *** DON'T EDIT //
package {{.PackageName}}

{{$psql := psql $.Dialect}}
{{$mysql := msql $.Dialect}}
{{$csql := csql $.Dialect}}
import (
	"context"
	"database/sql"
	"database/sql/driver"
	"fmt"
	"log"
	"time"
	"strings"
	"os"

	uuid "github.com/gofrs/uuid" {{if or $psql $csql}}
	_ "github.com/lib/pq" //import pq driver{{else}}
	_ "github.com/go-sql-driver/mysql"{{end}}
	"gitlab.com/astrotit/registration-api/net"
)

type dbConfig struct {
	Host     string
	Db       string
	Dbuser   string
	Password string
	Parameters []string
	Schema string
}

func (cfg dbConfig) parameters() string {
	parameters := ""
	if len(dbConfig.Parameters) > 0 {
		parameters += "?" + strings.Join(dbConfig.Parameters, "&")
	}
	return parameters
}

/*func (cfg dbConfig) Connect(ctx context.Context) (sql.Conn, error) {
	return , nil
}*/

// SQLContext context for sql operations
type SQLContext interface {
	WithTx(tx *sql.Tx) SQLContext
	WithDeadline(t time.Time) (SQLContext, context.CancelFunc)
	Exec(query string, args ...interface{}) (sql.Result, error)
	Query(query string, args ...interface{}) (*sql.Rows, error)
	QueryRow(query string, args ...interface{}) *sql.Row
	TxOptions() *sql.TxOptions
	TxID() uuid.UUID
	context.Context
}

type dbHandle interface {
	ExecContext(
		c context.Context,
		query string,
		args ...interface{},
	) (sql.Result, error)
	QueryContext(
		c context.Context,
		query string,
		args ...interface{},
	) (*sql.Rows, error)
	QueryRowContext(
		c context.Context,
		query string,
		args ...interface{},
	) *sql.Row
}

type sqlContext struct {
	txID      uuid.UUID
	tx        *sql.Tx
	isolation string
	context.Context
	txOptions *sql.TxOptions
}

func (c sqlContext) ctx() dbHandle {
	if c.tx != nil {
		return c.tx
	}
	return Dbase()
}

func (c sqlContext) WithTx(tx *sql.Tx) SQLContext {
	return sqlContext{
		tx:        tx,
		Context:   c.Context,
		txOptions: c.txOptions,
		txID:      c.txID,
	}
}

func (c sqlContext) WithDeadline(d time.Time) (SQLContext, context.CancelFunc) {
	ctx, cancel := context.WithDeadline(c.Context, d)
	return sqlContext{
		tx:        c.tx,
		Context:   ctx,
		txOptions: c.txOptions,
	}, cancel
}

func (c sqlContext) TxID() uuid.UUID {
	return c.txID
}

func (c sqlContext) TxOptions() *sql.TxOptions {
	return c.txOptions
}

// NewSQLContext new sql context
func NewSQLContext(ctx context.Context) SQLContext {
	return sqlContext{
		Context: ctx,
		txOptions: &sql.TxOptions{
			Isolation: sql.LevelSerializable,
			ReadOnly:  false,
		},
		txID: uuid.Must(uuid.NewV1()),
	}
}

// NewTxSQLContext new sql context with custom transaction options
func NewTxSQLContext(ctx context.Context, to *sql.TxOptions) SQLContext {
	return sqlContext{
		Context:   ctx,
		txOptions: to,
	}
}

func (c sqlContext) Exec(query string, args ...interface{}) (sql.Result, error) {
	return c.ctx().ExecContext(c, query, args...)
}

func (c sqlContext) Query(query string, args ...interface{}) (*sql.Rows, error) {
	return c.ctx().QueryContext(c, query, args...)
}

func (c sqlContext) QueryRow(query string, args ...interface{}) *sql.Row {
	return c.ctx().QueryRowContext(c, query, args...)
}

var dbio *sql.DB

// Dbase database io handle
func Dbase() *sql.DB {
	if dbio == nil {
		openConnection()
	}
	return dbio
}

func openConnection(dbconfig dbConfig) {
	log.Printf(
		"user=%s dbname=%s host=%s sslmode=disable",
		cfg.Dbuser,
		cfg.Db,
		cfg.Host
	)
	var err error
	dbio, err = sql.Open(
		{{if or $psql $csql}}"postgres"{{else}}"mysql"{{end}},
		fmt.Sprintf(
			"{{if or $psql $csql}}postgres://{{end}}%s:%s@%s/%s%s",
			cfg.Dbuser,
			cfg.Password,
			cfg.Host,
			cfg.Db,
			cfg.parameters(),
		),
	)
	if err != nil {
		log.Fatalf("error connecting to database :\n%s\n", err)
	}
}

// Transact execute ops in transaction
func Transact(ctx SQLContext, txFunc func(SQLContext) error) (err error) {
	var tx *sql.Tx
	tx, err = Dbase().BeginTx(ctx, ctx.TxOptions())
	if err != nil {
		return
	}
	ctx = ctx.WithTx(tx)
	defer func() {
		if p := recover(); p != nil {
			switch p := p.(type) {
			case error:
				err = p
			default:
				err = fmt.Errorf("%s", p)
			}
		}
		if err != nil {
			tx.Rollback()
			return
		}
		err = tx.Commit()
	}()
	return txFunc(ctx)
}

func configValue(key string) string {
	val, ok := os.LookupEnv(key)
	if !ok {
		panic(fmt.Sprintf("No value for key: %s \n", key))
	}
	return val
}

func loadConfig() dbConfig {
	cfg = dbConfig{}
	cfg.Host = configValue("DBHOST")
	cfg.Dbuser = configValue("DBUSER")
	cfg.Password = configValue("DBPASSWORD")
	cfg.Db = configValue("DB")
	{{if or $msql $csql}}cfg.Schema = cfg.Db{{else}}cfg.Schema = configValue("SCHEMA"){{end}}
	return cfg
}
{{end}}
