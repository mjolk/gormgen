{{define "level"}}// DON'T EDIT *** generated by ormgen *** DON'T EDIT //
package {{.PackageName}}
{{$proto := eq $.Etype "proto"}}
{{$psql := psql $.Dialect}}
{{$mysql := msql $.Dialect}}
{{$csql := csql $.Dialect}}
import (
	"database/sql" {{if or $psql $csql}}
	"github.com/lib/pq"{{else}}
	"github.com/go-sql-driver/mysql"{{end}}{{if $proto}}
	"github.com/mjolk/uuid"{{else}}
	"github.com/gofrs/uuid"{{end}}
	"fmt"
)
{{$level := .Level}}
{{$levels := .Levels}}

{{range .Tokens}}
{{if $.AtMaxLevel}}{{$ent := .}}
var {{.Name}}PropToSql = map[string]string{ {{range .Fields}}
	"{{deproxyfy .Name}}":`{{- template "embedfields" efields $ent . -}}`,{{end}}
}{{end}}

{{ if .Composite}}

func {{.Name}}From_lvl{{itoa $level}}() string { {{$basetpe := .Name}}
	return `FROM {{.Table}} {{.Alias}}{{range .Relations}}{{if .IsOneToMany }} LEFT JOIN {{.Table}} {{.Alias}} ON {{.ParentAlias}}.{{.From}} = {{.Alias}}.{{.To}}{{end}}{{if .IsManyToMany}} LEFT JOIN {{.LinkTable}} {{.LinkAlias}} ON {{.ParentAlias}}.{{.From}} = {{.LinkAlias}}.{{.To}} LEFT JOIN {{.Table}} {{.Alias}} ON {{.LinkAlias}}.{{.LinkFrom}} = {{.Alias}}.{{.LinkTo}}{{end}}{{if and .IsManyToOne (not .Embedded)}} LEFT JOIN {{.Table}} {{.Alias}} ON {{.ParentAlias}}.{{.From}} = {{.Alias}}.{{.To}}{{end}}{{end}}`
}

func {{.Name}}Select_lvl{{itoa $level}}() string { {{$tok := .}}
	return `SELECT {{range $fi, $fld := .Fields}}{{if $fi}}, {{end}}{{template "embedfields" efields $tok .}}{{end}}`
}

func {{$.Visibility}}oad{{title .Name}}_lvl{{itoa $level}}(rs *sql.Rows) (*{{.Name}}, error) {
	result, err := {{$.Visibility}}oad{{title .Name}}s_lvl{{itoa $level}}(rs)
	if err != nil {
		return nil, err
	}
	if len(result) > 1 {
		return nil, fmt.Errorf("More than one result, %d results found", len(result)) 
	} else if len(result) == 0 {
		return nil, sql.ErrNoRows
	}
	return result[0], nil
}

func {{$.Visibility}}oad{{title .Name}}s_lvl{{itoa $level}}(rs *sql.Rows) ([]*{{.Name}}, error) {
	var err error
	defer rs.Close()	
	result := make([]*{{.Name}}, 0)
	for rs.Next() {
		dest := []interface{}{ {{range .Fields}}
		{{ if isint .Type -}}new(sql.NullInt64){{ else if istime .Type -}}new({{if $mysql}}mysql{{else}}pq{{end}}.NullTime){{else if isbool .Type -}}new(sql.NullBool){{else if isstring .Type -}}new(sql.NullString){{else if isuuid .Type}}new(uuid.NullUUID){{else if isbyte .Type}}&[]byte{}{{else -}}new(sql.RawBytes){{end}},{{end}}
		}
		if err = rs.Scan(dest...); err != nil {
			return nil, err
		}
		s := newProxy{{.Name}}(){{$allrel := .Relations}}{{range .Relations}}
		s.{{.ProxyFieldName}} = {{if .Proxy}}newProxy{{.Type}}(){{else}}new({{.Type}}){{end}}{{if .IsManyToOne}}{{if .HasChildIsList $allrel}}
		s.{{reproxyfy .ProxyFieldName}} = newProxy{{.Type}}(){{end}}{{end}}{{end}}{{range $idx, $field := .Fields}}
		s.{{.Name}} = {{if isint .Type}}checkSqlInt64Value(dest[{{$idx}}]){{else if isbool .Type}}checkSqlBoolValue(dest[{{$idx}}]){{ else if istime .Type}}checkSqlTimeValue(dest[{{$idx}}]){{else if isbyte .Type}}*dest[{{$idx}}].(*[]byte){{else if isuuid .Type}}checkSqlUUIDValue(dest[{{$idx}}]){{else}}checkSqlStringValue(dest[{{$idx}}]){{end}}{{end}}
		entity := s.{{.Name}}
		var newID bool = true
		for _, ent := range result {
			if ent.ID == s.ID {
				entity = ent
				newID = false
			}
		}{{$token := .}}
		{{range .RootRelations}}
		{{template "merge" relarg $token . nil .}}
		{{end}}
                if newID {
			result = append(result, entity)
		}
	}
	if cErr := rs.Close(); cErr != nil {
		return nil, cErr
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return result, nil
}

{{end}}
{{end}}{{end}}

{{define "merge"}}
{{$token := .Token}}{{$relation := .Relation}}{{$root := .RootRelation}}{{$fields:= .Token.Fields}}{{$relations := .Token.Relations}}{{if or .Relation.IsOneToMany .Relation.IsManyToMany}}New{{tovar .Relation.FieldName}}ID := true
		if s.{{.Relation.ProxyFieldName}}.ID != 0 { {{$parentlist := listfields .ParentRelation}}
			var {{typeprefix .Relation ""}}{{.Relation.Type}} *{{.Relation.Type}}
			if len({{if checkparent .ParentRelation}}{{typeprefix .ParentRelation ""}}{{.ParentRelation.Type}}.{{.Relation.Field}}{{else if ne $parentlist ""}}{{typeprefix .Relation $parentlist}}{{$parentlist}}.{{.Relation.Field}}{{else}}entity.{{.Relation.FieldName}}{{end}}) > 0 {
				for _, rel := range {{if checkparent .ParentRelation}}{{typeprefix .ParentRelation ""}}{{.ParentRelation.Type}}.{{.Relation.Field}}{{else if ne $parentlist ""}}{{typeprefix .Relation $parentlist}}{{$parentlist}}.{{.Relation.Field}}{{else}}entity.{{.Relation.FieldName}}{{end}} {
				if rel.ID == s.{{.Relation.ProxyFieldName}}.ID{{if .Relation.IsManyToMany}} && rel.LinkID == s.{{.Relation.ProxyFieldName}}.LinkID{{end}} {
						New{{tovar .Relation.FieldName}}ID = false
						{{typeprefix .Relation ""}}{{.Relation.Type}} = rel
					}
				}
			} 
			if New{{tovar .Relation.FieldName}}ID { 
				{{typeprefix .Relation ""}}{{.Relation.Type}} = new({{.Relation.Type}}){{$omfiltrd := norel $fields .Relation.ProxyFieldName}}{{$omntpe := .Relation.Type}}{{$rell := .Relation}}
				{{range $a, $b := $omfiltrd}}{{if $a}}
				{{end}}{{typeprefix $rell ""}}{{$omntpe}}.{{proxyshift .}} = s.{{.}}{{end}} }{{end}}
				{{range .Relation.SubRelations .Token.Relations}}{{template "merge" relarg $token . $relation $root}}{{end}}
				{{if or .Relation.IsOneToMany .Relation.IsManyToMany}}if New{{tovar .Relation.FieldName}}ID { {{if .ParentRelation}}{{$parentlist := listfields .ParentRelation}}{{if checkparent .ParentRelation}}{{typeprefix .ParentRelation ""}}{{.ParentRelation.Type}}.{{.Relation.Field}}{{else if ne $parentlist ""}}{{typeprefix .Relation $parentlist}}{{$parentlist}}.{{.Relation.Field}}{{else}}entity.{{.Relation.FieldName}}{{end}} = append({{if checkparent .ParentRelation}}{{typeprefix .ParentRelation ""}}{{.ParentRelation.Type}}.{{.Relation.Field}}{{else if ne $parentlist ""}}{{typeprefix .Relation $parentlist}}{{$parentlist}}.{{.Relation.Field}}{{else}}entity.{{.Relation.FieldName}}{{end}}, {{typeprefix .Relation ""}}{{.Relation.Type}})}{{else}}
				entity.{{.RootRelation.FieldName}} = append(entity.{{.RootRelation.FieldName}}, {{typeprefix .Relation ""}}{{.Relation.Type}})}{{end}}
		}{{end}}
{{end}}
{{define "embedfields"}}{{if .Field.Embedded}}{{.Field.Relation.ParentAlias}}.{{.Field.Relation.Table}}_{{.Field.Column}}{{else}}{{updatealias .Token .Field .Field.Alias}}.{{.Field.Column}}{{end}}{{end}}



