{{define "main"}}// DON'T EDIT *** generated by ormgen *** DON'T EDIT //

package {{.PackageName}}

import (
	"database/sql"
	"github.com/lib/pq"
	"errors"
	"log"
	"strings"
	"time"
	"fmt"
)

func checkSqlInt64Value(v interface{}) int64 {
	val := v.(*sql.NullInt64)
	if !val.Valid {
		return 0
	}
	return val.Int64
}

func checkSqlStringValue(v interface{}) string {
	val := v.(*sql.NullString)
	if !val.Valid {
		return ""
	}
	return val.String
}

func checkSqlBoolValue(v interface{}) bool {
	val := v.(*sql.NullBool)
	if !val.Valid {
		return false
	}
	return val.Bool
}

func checkSqlTimeValue(v interface{}) time.Time {
	val := v.(*pq.NullTime)
	if !val.Valid {
		return time.Time{}
	}
	return val.Time
}

{{$level := .Level}}
{{$levels := .Levels}}

{{range .Tokens}}

//postgresql specific shit
func {{.Name}}LastInsertID(tx *sql.Tx) (int64, error) {
       var nId int64

       //postgresql way of retrieving the last inserted id inside a tx, concurrent safe
       if err := tx.QueryRow("select currval('{{tolower .Name}}_{{tolower .IdColumn}}_seq')").Scan(&nId); err != nil {
               return 0, err
       }
       return nId, nil
}

{{$native := native .Fields}}{{$linkfields := linkprops .Name}}{{$linkrels := linkrels .Name}}
type sql{{.Name}} struct { {{range $native}}
	{{.Name}} {{ if isint .Type -}}sql.NullInt64{{- else if isbool .Type -}}sql.NullBool{{- else if istime .Type -}}pq.NullTime{{- else if isbyte .Type -}}[]byte{{else}}sql.NullString{{end}}{{end}}{{range .RootRelations}}{{if .IsManyToOne}}
	{{.Field}} *sql{{.Type}}{{end}}{{end}}{{range $linkfields}}
	{{field .Name}} {{ if isint .Type -}}sql.NullInt64{{- else if isbool .Type -}}sql.NullBool{{- else if istime .Type -}}pq.NullTime{{- else if isbyte .Type -}}[]byte{{else}}sql.NullString{{end}}{{end}}{{range $linkrels}}
	{{.Field}} *sql{{.Type}}{{end}}
}

type sqlProxy{{.Name}} struct {
	*sql{{.Name}}{{range .RootRelations}}
	proxy{{.Field}} *sqlProxy{{.Type}}{{end}}{{range proxysubrels .Name}}
	proxy{{.Field}} *sqlProxy{{.Type}}{{end}}
}

type proxy{{.Name}} struct {
	*{{.Name}}{{range .RootRelations}}
	proxy{{.Field}} *proxy{{.Type}}{{end}}{{range proxysubrels .Name}}
	proxy{{.Field}} *proxy{{.Type}}{{end}}
}

func newSqlProxy{{.Name}} () *sqlProxy{{.Name}} {
	return &sqlProxy{{.Name}}{ sql{{.Name}}:new(sql{{.Name}})}
}

func newProxy{{.Name}} () *proxy{{.Name}} {
	return &proxy{{.Name}}{ {{.Name}}:new({{.Name}})}
}

type {{.Name}}Query struct {
	depth int
	query string
	params []interface{}
}

func New{{.Name}}Query(lvl int) *{{.Name}}Query {
	return &{{.Name}}Query{
			query:fmt.Sprintf("%s %s", {{.Name}}Select(lvl), {{.Name}}From(lvl)), 
			params:make([]interface{}, 0),
			depth: lvl,
		}
}

//TODO add where in
func (q *{{.Name}}Query) Where(prop string, value interface{}) *{{.Name}}Query {
	q.params = append(q.params, value)
	q.query = fmt.Sprintf("%s WHERE %s = $%d", q.query, {{.Name}}PropToSql[prop], len(q.params))
	return q
}

//TODO validate previous existence of where
func (q *{{.Name}}Query) And(prop string, value interface{}) *{{.Name}}Query {
	q.params = append(q.params, value)
	q.query = fmt.Sprintf("%s AND %s = $%d", q.query, {{.Name}}PropToSql[prop], len(q.params))
	return q
}

func (q *{{.Name}}Query) Or(prop string, value interface{}) *{{.Name}}Query {
	q.params = append(q.params, value)
	q.query = fmt.Sprintf("%s OR %s = $%d", q.query, {{.Name}}PropToSql[prop], len(q.params))
	return q
}

//TODO allow multiple columns to sort on
func (q *{{.Name}}Query) OrderBy(prop, dir string) *{{.Name}}Query {
	q.query = fmt.Sprintf("%s ORDER BY %s %s", q.query, {{.Name}}PropToSql[prop], dir)
	return q
}

func (q *{{.Name}}Query) Execute(tx *sql.Tx) ([]*{{.Name}}, error) {
	return Query{{title .Name}}s(q.query, q.params, q.depth, tx)
}

func (q *{{.Name}}Query) Single(tx *sql.Tx) (*{{.Name}}, error) {
	return Query{{title .Name}}(q.query, q.params, q.depth, tx)
}

func Find{{title .Name}}ByID(id int, lvl int, tx *sql.Tx) (*{{.Name}}, error) {
        return New{{.Name}}Query(lvl).Where("ID", id).Single(tx)
}

{{ if .Composite}}

type {{title .Name}}Loader func(*sql.Rows) ([]*{{.Name}}, error)

type Single{{title .Name}}Loader func(*sql.Rows) (*{{.Name}}, error)

var {{.Name}}Loaders map[int]{{.Name}}Loader = map[int]{{.Name}}Loader{ {{$name := .Name}}{{range $lvl, $irrel := $levels}}
	{{$lvl}}:{{$.Visibility}}oad{{title $name}}s_lvl{{itoa $lvl}},{{end}}
}

var Single{{.Name}}Loaders map[int]Single{{.Name}}Loader = map[int]Single{{.Name}}Loader{ {{$name := .Name}}{{range $lvl, $irrel := $levels}}
	{{$lvl}}:{{$.Visibility}}oad{{title $name}}_lvl{{itoa $lvl}},{{end}}
}

func Query{{title .Name}}s(query string, params []interface{}, lvl int, tx *sql.Tx) ([]*{{.Name}}, error) {
	var rows *sql.Rows
	var err error
	if tx != nil {
		rows, err = tx.Query(query, params...)	
	} else {
		rows, err = Dbase().Query(query, params...)	
	}
	if err != nil {
		log.Fatal(err)
		return []*{{.Name}}{}, err
	}
	return {{.Name}}Loaders[lvl](rows)
}

func Query{{title .Name}}(query string, params []interface{}, lvl int, tx *sql.Tx) (*{{.Name}}, error) {
	var rows *sql.Rows
	var err error
	if tx != nil {
		rows, err = tx.Query(query, params...)
	} else {
		rows, err = Dbase().Query(query, params...)
	}
	if err != nil {
		log.Fatal(err)
		return nil, err
	}
	return Single{{.Name}}Loaders[lvl](rows)
}

var {{.Name}}Selects map[int]func()string = map[int]func()string{ {{$name := .Name}}{{range $lvl, $irrel := $levels}}
	{{$lvl}}:{{title $name}}Select_lvl{{itoa $lvl}},{{end}}
}

func {{.Name}}Select(lvl int) string {
	return {{.Name}}Selects[lvl]()
}

var {{.Name}}Froms map[int]func()string = map[int]func()string{ {{$name := .Name}}{{range $lvl, $irrel := $levels}}
	{{$lvl}}:{{title $name}}From_lvl{{itoa $lvl}},{{end}}
}

func {{.Name}}From(lvl int) string {
	return {{.Name}}Froms[lvl]()
}

func Insert{{title .Name}}(entity *{{.Name}}, tx *sql.Tx) (err error) { {{$sfields := .Fields}} {{$owner := .Name}}{{$relations := .Relations}}{{$natfields := ffiltersliceandid .Fields}}
	values := make([]interface{}, 0){{range $natfields}}{{if isreference .}}
	if entity.{{referenceonly .Name}} == nil {
		values = append(values, nil)
	} else {
		values = append(values, entity.{{.Name}})
	}{{else}}
	values = append(values, entity.{{.Name}}){{end}}{{end}}
	if len(values) == 0 {
		if tx != nil {
			_, err = tx.Exec(`INSERT INTO {{.Table}} DEFAULT VALUES`)
		} else {
			_, err = Dbase().Exec(`INSERT INTO {{.Table}} DEFAULT VALUES`)
		}
		return
	}
	if tx != nil {
		_, err = tx.Exec(`INSERT INTO {{.Table}} ({{range $fi, $fld := $natfields}}{{if $fi}}, {{end}}{{switch2fk .}}{{end}}) VALUES({{range $idx, $fldx := $natfields}}{{if $idx}}, {{end}}${{plus1 $idx}}{{end}})`, values...)
	} else {
		_, err = Dbase().Exec(`INSERT INTO {{.Table}} ({{range $fi, $fld := $natfields}}{{if $fi}}, {{end}}{{switch2fk .}}{{end}}) VALUES({{range $idx, $fldx := $natfields}}{{if $idx}}, {{end}}${{plus1 $idx}}{{end}})`, values...)
	}/*
	{{$fields:=.Fields}}{{range .RootRelations}}{{if .IsOneToMany}}
	if len(entity.{{.FieldName}}) > 0 {
		for _, rel := range entity.{{.Field}} {
			err = Insert{{.Type}}(rel, tx)
			if err != nil {
				return
			}
		}
	}{{end}}{{if .IsManyToMany}}
	if len(entity.{{.Field}}) > 0 {
		for _, rel := range entity.{{.Field}} { {{$natffields := ffilter $sfields .Field}}{{$linktpe := .LinkType}}{{$tolinktpe := .Type}}
			linkEntity := new({{.LinkType}}){{range .SubRelations $relations}}{{if .LinkRelation}}
			linkEntity.{{.Field}} = new({{.Type}}){{end}}{{end}}
		 	linkEntity.{{$owner}}ID = entity.ID
			linkEntity.{{$tolinktpe}}ID = rel.ID {{range $natffields}}{{if .IsLinkField}}
			linkEntity.{{fieldshift .Name}} = rel.{{fieldshift .Name}}{{end}}{{end}}{{range .SubRelations $relations}}{{if .LinkRelation}}
			linkEntity.{{.Type}}.ID = rel.{{.Type}}.ID{{end}}{{end}}
			err = Insert{{.LinkType}}(linkEntity, tx)
			if err != nil {
				return
			}
		}
	}{{end}}{{end}}*/
	return
}

func Update{{title .Name}}(entity *{{.Name}}, tx *sql.Tx) (err error) { {{$natfields := ffiltersliceandid .Fields}}
	if entity.ID == 0 {
		return errors.New("Cannot update without entity identifier")
	}{{$l := len $natfields}}
	queryPrts := make([]string, 0)
	updateFields := make([]interface{}, 0){{range $fi, $fld := $natfields}}{{if isreference .}}
	if entity.{{referenceonly .Name}} == nil {
		updateFields = append(updateFields, nil)
	} else {
		updateFields = append(updateFields, entity.{{.Name}})
	}{{else}}
	updateFields = append(updateFields, entity.{{.Name}}){{end}}
	queryPrts = append(queryPrts, `SET {{switch2fk .}} = ${{plus1 $fi}}`){{end}}
	queryStr := strings.Join(queryPrts, ", ") + ` WHERE {{.IdColumn}} = ${{plus1 $l}}`
	updateFields = append(updateFields, entity.ID)
	if tx != nil {
		_, err = tx.Exec(`UPDATE {{.Table}} ` + queryStr, updateFields...)
	} else {
		_, err = Dbase().Exec(`UPDATE {{.Table}} ` + queryStr, updateFields...)
	}
	return
}

{{else}}

func {{.Name}}From(lvl int) string { {{$basetpe := .Name}}
	return `FROM {{.Table}} {{.Alias}}`
}

func {{.Name}}Select(lvl int) string { {{$tok := .}}
	return `SELECT {{range $fi, $fld := .Fields}}{{if $fi}}, {{end}}{{updatealias $tok . .Alias}}.{{.Column}}{{end}}`
}

func Insert{{title .Name}}(entity *{{.Name}}, tx *sql.Tx) (err error) { {{$natfields := ffilternatid .Fields}}
	if tx != nil {
		_, err = tx.Exec(`INSERT INTO {{.Table}} ({{range $fi, $fld := $natfields}}{{if $fi}}, {{end}}{{.Column}}{{end}}) VALUES({{range $idx, $fldx := $natfields}}{{if $idx}}, {{end}}${{plus1 $idx}}{{end}})`, {{range $fi, $fld := $natfields}}{{if $fi}}, {{end}}entity.{{.Name}}{{end}})
	} else {
		_, err = Dbase().Exec(`INSERT INTO {{.Table}} ({{range $fi, $fld := $natfields}}{{if $fi}}, {{end}}{{.Column}}{{end}}) VALUES({{range $idx, $fldx := $natfields}}{{if $idx}}, {{end}}${{plus1 $idx}}{{end}})`, {{range $fi, $fld := $natfields}}{{if $fi}}, {{end}}entity.{{.Name}}{{end}})
	}
	return
}

func Query{{title .Name}}(query string, params []interface{}, lvl int, tx *sql.Tx) (*{{.Name}}, error) {
	var row *sql.Row
	if tx != nil {
		row = Dbase().QueryRow(query, params...)
	} else {
		row = tx.QueryRow(query, params...)
	}
	return Load{{title .Name}}(row)
}

func Query{{title .Name}}s(query string, params []interface{}, lvl int, tx *sql.Tx) ([]*{{.Name}}, error) {
	var rows *sql.Rows
	var err error
	if tx != nil {
		rows, err = tx.Query(query, params...)
	} else {
		rows, err = Dbase().Query(query, params...)
	}
	if err != nil {
		log.Fatal(err)
		return []*{{.Name}}{}, err
	}
	return Load{{title .Name}}s(rows)
}

func {{$.Visibility}}oad{{title .Name}}(r *sql.Row) (*{{.Name}}, error) {
	var s sql{{.Name}}
	if err := r.Scan({{range .Fields}}
		&s.{{.Name}},{{end}}
	); err != nil {
		return nil, err
	}
	var t {{.Name}}{{range .Fields}}
	t.{{.Name}} = {{if isint .Type}}checkSqlInt64Value(s.{{.Name}}){{else if isbool .Type}}checkSqlBoolValue(s.{{.Name}}){{else if istime .Type}}checkSqlTimeValue(s.{{.Name}}){{else if isbyte .Type}}s.{{.Name}}{{else}}checkSqlStringValue(s.{{.Name}}){{end}}{{end}}
	return &t, nil
}

func {{$.Visibility}}oad{{title .Name}}s(rs *sql.Rows) ([]*{{.Name}}, error) {
	structs := make([]*{{.Name}}, 0, 16)
	var err error
	for rs.Next() {
		var s sql{{.Name}}
		if err = rs.Scan({{range .Fields}}
			&s.{{.Name}},{{end}}
		); err != nil {
			return nil, err
		}
		var t {{.Name}}{{range .Fields}}
		t.{{.Name}} = {{if isint .Type}}checkSqlInt64Value(s.{{.Name}}){{else if isbool .Type}}checkSqlBoolValue(s.{{.Name}}){{else if istime .Type}}checkSqlTimeValue(s.{{.Name}}){{else if isbyte .Type}}s.{{.Name}}{{else}}checkSqlStringValue(s.{{.Name}}){{end}}{{end}}
		structs = append(structs, &t)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}
{{end}}
{{end}}{{end}}
