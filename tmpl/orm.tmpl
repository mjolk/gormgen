{{define "main"}}// DON'T EDIT *** generated by ormgen *** DON'T EDIT //
package {{.PackageName}}

import (
	"database/sql"
	"github.com/lib/pq"
	"github.com/satori/go.uuid"
	"errors"
	"strings"
	"time"
	"fmt"
)

func checkSqlUUIDValue(v interface{}) uuid.UUID {
	val := v.(*uuid.NullUUID)
	if !val.Valid{
		return uuid.UUID{}	
	}
	return val.UUID
} 

func checkSqlInt64Value(v interface{}) int64 {
	val := v.(*sql.NullInt64)
	if !val.Valid {
		return 0
	}
	return val.Int64
}

func checkSqlStringValue(v interface{}) string {
	val := v.(*sql.NullString)
	if !val.Valid {
		return ""
	}
	return val.String
}

func checkSqlBoolValue(v interface{}) bool {
	val := v.(*sql.NullBool)
	if !val.Valid {
		return false
	}
	return val.Bool
}

func checkSqlTimeValue(v interface{}) time.Time {
	val := v.(*pq.NullTime)
	if !val.Valid {
		return time.Time{}
	}
	return val.Time
}

{{$level := .Level}}
{{$levels := .Levels}}

{{range .Tokens}}

//postgresql specific shit
func {{.Name}}LastInsertID(ctx SQLContext) (int64, error) {
       	var nId int64
       	if err := ctx.QueryRow(strings.Replace("select currval('[SCHEMA].{{tolower .Table}}_{{tolower .IDColumn}}_seq')", "[SCHEMA]", ctx.Schema(), -1)).Scan(&nId); err != nil {
               	return 0, err
       	}
       	return nId, nil
}

type proxy{{.Name}} struct {
	*{{.Name}}{{range .RootRelations}}
	proxy{{.Field}} *proxy{{.Type}}{{end}}{{range proxysubrels .Name}}
	proxy{{.Field}} *proxy{{.Type}}{{end}}
}

func newProxy{{.Name}} () *proxy{{.Name}} {
	return &proxy{{.Name}}{ {{.Name}}:new({{.Name}})}
}

type {{.Name}}Query struct {
	depth int
	query string
	params []interface{}
}

func New{{.Name}}Query(lvl int) *{{.Name}}Query {
	return &{{.Name}}Query{
			query:fmt.Sprintf("%s %s", {{.Name}}Select(lvl), {{.Name}}From(lvl)), 
			params:make([]interface{}, 0),
			depth: lvl,
		}
}

//TODO add where in
func (q *{{.Name}}Query) Where(prop, operator string, value interface{}) *{{.Name}}Query {
	q.params = append(q.params, value)
	q.query = fmt.Sprintf("%s WHERE %s %s $%d", q.query, {{.Name}}PropToSql[prop], operator, len(q.params))
	return q
}

//TODO validate previous existence of where
func (q *{{.Name}}Query) And(prop, operator string, value interface{}) *{{.Name}}Query {
	q.params = append(q.params, value)
	q.query = fmt.Sprintf("%s AND %s %s $%d", q.query, {{.Name}}PropToSql[prop], operator, len(q.params))
	return q
}

func (q *{{.Name}}Query) Or(prop string, operator string, value interface{}) *{{.Name}}Query {
	q.params = append(q.params, value)
	q.query = fmt.Sprintf("%s OR %s %s $%d", q.query, {{.Name}}PropToSql[prop], operator, len(q.params))
	return q
}

func (q *{{.Name}}Query) Limit(value int) *{{.Name}}Query {
	q.params = append(q.params, value)
	q.query = fmt.Sprintf("%s LIMIT %d", q.query, len(q.params))
	return q
}

//TODO allow multiple columns to sort on
func (q *{{.Name}}Query) OrderBy(prop, dir string) *{{.Name}}Query {
	q.query = fmt.Sprintf("%s ORDER BY %s %s", q.query, {{.Name}}PropToSql[prop], dir)
	return q
}

func (q *{{.Name}}Query) KeyUp(prop string, start, limit int) *{{.Name}}Query {
	sqlProp := {{.Name}}PropToSql[prop]
	q.params = append(q.params, limit)
	q.query = strings.Replace(q.query, "FROM [SCHEMA].{{tolower .Table}}", "FROM (SELECT * FROM [SCHEMA].{{tolower .Table}} LIMIT $1) AS", 1)
	if start > 0 {
		q.params = append(q.params, start)
		q.query = fmt.Sprintf("%s WHERE %s > $2 ORDER BY %s ASC", q.query, sqlProp, sqlProp)
	} else {
		q.query = fmt.Sprintf("%s ORDER BY %s ASC", q.query, sqlProp)
	}
	return q
}

func (q *{{.Name}}Query) KeyDown(prop string, start, limit int) *{{.Name}}Query {
	q.params = append(q.params, start)
	q.params = append(q.params, limit)
	sqlProp := {{.Name}}PropToSql[prop]
	props := strings.Split(sqlProp, ".")
	q.query = strings.Replace(q.query, "FROM [SCHEMA].{{tolower .Table}}", "FROM (SELECT * FROM [SCHEMA].{{tolower .Table}} WHERE %s < $1 ORDER BY %s DESC LIMIT $2) AS", 1)
	q.query = fmt.Sprintf(q.query, props[len(props)-1], props[len(props)-1])
	q.query = fmt.Sprintf(`SELECT t.* FROM ( %s ) AS t ORDER BY t.%s ASC`, 
			q.query, props[len(props)-1])
	return q	
}
	

func (q *{{.Name}}Query) Execute(ctx SQLContext) ([]*{{.Name}}, error) {
	q.query = strings.Replace(q.query, "[SCHEMA]", ctx.Schema(), -1)
	return Query{{title .Name}}s(q.query, q.params, q.depth, ctx)
}

func (q *{{.Name}}Query) Single(ctx SQLContext) (*{{.Name}}, error) {
	q.query = strings.Replace(q.query, "[SCHEMA]", ctx.Schema(), -1)
	return Query{{title .Name}}(q.query, q.params, q.depth, ctx)
}

func Find{{title .Name}}ByID(id {{.IDType}}, lvl int, ctx SQLContext) (*{{.Name}}, error) {
        return New{{.Name}}Query(lvl).Where("ID", "=", id).Single(ctx)
}

{{if not .LinkEntity}}
func Delete{{title .Name}}(entity *{{.Name}}, ctx SQLContext) (err error) {
	if entity.ID == {{if eq .IDType "int64"}}0{{else if eq .IDType "uuid.UUID"}}uuid.Nil{{else}}nil{{end}} {
		return errors.New("Cannot delete without entity identifier")
	}
	query := strings.Replace("DELETE FROM [SCHEMA].{{.Table}} WHERE {{.IDColumn}} = $1", "[SCHEMA]", ctx.Schema(), -1)
	_, err = ctx.Exec(query, entity.ID)
	return
}
{{else}}//hack - need to check if this is a good permanent solution and not only for this schema
func Delete{{title .Name}}(entity *{{.Name}}, ctx SQLContext) (err error) { {{$natfields := ffilternatid .Fields}}
	queryWhere := `WHERE {{range $fi, $fld := $natfields}}{{if $fi}} AND {{end}}{{.Column}} = ${{plus1 $fi}}{{end}}`
	query := strings.Replace("DELETE FROM [SCHEMA].{{.Table}} " + queryWhere, "[SCHEMA]", ctx.Schema(), -1)
	_, err = ctx.Exec(query, {{range $fi, $fld := $natfields}}{{if $fi}}, {{end}}entity.{{.Name}}{{end}})
	return
}
{{end}}
{{ if .Composite}}

type {{title .Name}}Loader func(*sql.Rows) ([]*{{.Name}}, error)

type Single{{title .Name}}Loader func(*sql.Rows) (*{{.Name}}, error)

var {{.Name}}Loaders map[int]{{.Name}}Loader = map[int]{{.Name}}Loader{ {{$name := .Name}}{{range $lvl, $irrel := $levels}}
	{{$lvl}}:{{$.Visibility}}oad{{title $name}}s_lvl{{itoa $lvl}},{{end}}
}

var Single{{.Name}}Loaders map[int]Single{{.Name}}Loader = map[int]Single{{.Name}}Loader{ {{$name := .Name}}{{range $lvl, $irrel := $levels}}
	{{$lvl}}:{{$.Visibility}}oad{{title $name}}_lvl{{itoa $lvl}},{{end}}
}

func Query{{title .Name}}s(query string, params []interface{}, lvl int, ctx SQLContext) ([]*{{.Name}}, error) {
	rows, err := ctx.Query(query, params...)
	if err != nil {
		return []*{{.Name}}{}, err
	}
	return {{.Name}}Loaders[lvl](rows)
}

func Query{{title .Name}}(query string, params []interface{}, lvl int, ctx SQLContext) (*{{.Name}}, error) {
	rows, err := ctx.Query(query, params...)
	if err != nil {
		return nil, err
	}
	return Single{{.Name}}Loaders[lvl](rows)
}

var {{.Name}}Selects map[int]func()string = map[int]func()string{ {{$name := .Name}}{{range $lvl, $irrel := $levels}}
	{{$lvl}}:{{title $name}}Select_lvl{{itoa $lvl}},{{end}}
}

func {{.Name}}Select(lvl int) string {
	return {{.Name}}Selects[lvl]()
}

var {{.Name}}Froms map[int]func()string = map[int]func()string{ {{$name := .Name}}{{range $lvl, $irrel := $levels}}
	{{$lvl}}:{{title $name}}From_lvl{{itoa $lvl}},{{end}}
}

func {{.Name}}From(lvl int) string {
	return {{.Name}}Froms[lvl]()
}



func Insert{{title .Name}}(entity *{{.Name}}, ctx SQLContext) (err error) { {{$sfields := .Fields}} {{$owner := .Name}}{{$relations := .Relations}}{{$natfields := ffiltersliceandid .Fields}}
	var query string
	values := make([]interface{}, 0){{range $natfields}}{{if isreference .}}
	if entity.{{referenceonly .Name}} == nil {
		values = append(values, nil)
	} else {
		values = append(values, entity.{{.Name}})
	}{{else}}
	values = append(values, entity.{{.Name}}){{end}}{{end}}
	if len(values) == 0 {
		query = `INSERT INTO [SCHEMA].{{.Table}} DEFAULT VALUES`
	} else {
		query = `INSERT INTO [SCHEMA].{{.Table}} ({{range $fi, $fld := $natfields}}{{if $fi}}, {{end}}{{switch2fk .}}{{end}}) VALUES({{range $idx, $fldx := $natfields}}{{if $idx}}, {{end}}${{plus1 $idx}}{{end}})`
	}
	query = strings.Replace(query, "[SCHEMA]", ctx.Schema(), -1)
	_, err = ctx.Exec(query, values...)
	/*
	{{$fields:=.Fields}}{{range .RootRelations}}{{if .IsOneToMany}}
	if len(entity.{{.FieldName}}) > 0 {
		for _, rel := range entity.{{.Field}} {
			err = Insert{{.Type}}(rel, tx)
			if err != nil {
				return
			}
		}
	}{{end}}{{if .IsManyToMany}}
	if len(entity.{{.Field}}) > 0 {
		for _, rel := range entity.{{.Field}} { {{$natffields := ffilter $sfields .Field}}{{$linktpe := .LinkType}}{{$tolinktpe := .Type}}
			linkEntity := new({{.LinkType}}){{range .SubRelations $relations}}{{if .LinkRelation}}
			linkEntity.{{.Field}} = new({{.Type}}){{end}}{{end}}
		 	linkEntity.{{$owner}}ID = entity.ID
			linkEntity.{{$tolinktpe}}ID = rel.ID {{range $natffields}}{{if .IsLinkField}}
			linkEntity.{{fieldshift .Name}} = rel.{{fieldshift .Name}}{{end}}{{end}}{{range .SubRelations $relations}}{{if .LinkRelation}}
			linkEntity.{{.Type}}.ID = rel.{{.Type}}.ID{{end}}{{end}}
			err = Insert{{.LinkType}}(linkEntity, tx)
			if err != nil {
				return
			}
		}
	}{{end}}{{end}}*/
	return
}

func Update{{title .Name}}(entity *{{.Name}}, ctx SQLContext) (err error) { {{$natfields := ffiltersliceandid .Fields}}
	if entity.ID == {{if eq .IDType "uuid.UUID"}}uuid.Nil{{else}}0{{end}} {
		return errors.New("Cannot update without entity identifier")
	}{{$l := len $natfields}}
	queryPrts := make([]string, 0)
	updateFields := make([]interface{}, 0){{range $fi, $fld := $natfields}}{{if isreference .}}
	if entity.{{referenceonly .Name}} == nil || entity.{{.Name}} == {{if eq .Type "uuid.UUID"}}uuid.Nil{{else}}0{{end}} {
		updateFields = append(updateFields, nil)
	} else {
		updateFields = append(updateFields, entity.{{.Name}})
	}{{else}}
	updateFields = append(updateFields, entity.{{.Name}}){{end}}
	queryPrts = append(queryPrts, `{{switch2fk .}} = ${{plus1 $fi}}`){{end}}
	//queryStr := strings.Join(queryPrts, ", ") + ` WHERE {{.IDColumn}} = ${{plus1 $l}}`
	queryStr := fmt.Sprintf("SET %s WHERE {{.IDColumn}} = ${{plus1 $l}}", strings.Join(queryPrts, ", "))
	updateFields = append(updateFields, entity.ID)
	query := strings.Replace(`UPDATE [SCHEMA].{{.Table}} ` + queryStr, "[SCHEMA]", ctx.Schema(), -1)
	_, err = ctx.Exec(query, updateFields...)
	return
}
{{else}}

func {{.Name}}From(lvl int) string { {{$basetpe := .Name}}
	return `FROM [SCHEMA].{{.Table}} {{.Alias}}`
}

func {{.Name}}Select(lvl int) string { {{$tok := .}}
	return `SELECT {{range $fi, $fld := .Fields}}{{if $fi}}, {{end}}{{updatealias $tok . .Alias}}.{{.Column}}{{end}}`
}

{{if ne .IDType ""}}
func Update{{title .Name}}(entity *{{.Name}}, ctx SQLContext) (err error) { {{$natfields := ffiltersliceandid .Fields}}
	if entity.ID == {{if eq .IDType "uuid.UUID"}}uuid.Nil{{else}}0{{end}} {
		return errors.New("Cannot update without entity identifier")
	}{{$l := len $natfields}}
	queryPrts := make([]string, 0)
	updateFields := make([]interface{}, 0){{range $fi, $fld := $natfields}}
	updateFields = append(updateFields, entity.{{.Name}})
	queryPrts = append(queryPrts, `{{switch2fk .}} = ${{plus1 $fi}}`){{end}}
	//queryStr := strings.Join(queryPrts, ", ") + ` WHERE {{.IDColumn}} = ${{plus1 $l}}`
	queryStr := fmt.Sprintf("SET %s WHERE {{.IDColumn}} = ${{plus1 $l}}", strings.Join(queryPrts, ", "))
	updateFields = append(updateFields, entity.ID)
	query := strings.Replace(`UPDATE [SCHEMA].{{.Table}} ` + queryStr, "[SCHEMA]", ctx.Schema(), -1)
	_, err = ctx.Exec(query, updateFields...)
	return
}
{{end}}


func Insert{{title .Name}}(entity *{{.Name}}, ctx SQLContext) (err error) { {{$natfields := ffilternatid .Fields}} {{$uuid := eq .IDType "uuid.UUID"}}
query := `INSERT INTO [SCHEMA].{{.Table}} ({{if $uuid}}{{.IDColumn}}, {{end}}{{range $fi, $fld := $natfields}}{{if $fi}}, {{end}}{{.Column}}{{end}}) VALUES({{if $uuid}}$1, {{end}}{{range $idx, $fldx := $natfields}}{{if $idx}}, {{end}}${{if $uuid}}{{plus2 $idx}}{{else}}{{plus1 $idx}}{{end}}{{end}})`
	query = strings.Replace(query, "[SCHEMA]", ctx.Schema(), -1)
	_, err = ctx.Exec(query, {{if $uuid}}entity.ID, {{end}}{{range $fi, $fld := $natfields}}{{if $fi}}, {{end}}entity.{{.Name}}{{end}})
	return
}

func Query{{title .Name}}(query string, params []interface{}, lvl int, ctx SQLContext) (*{{.Name}}, error) {
	return Load{{title .Name}}(ctx.QueryRow(query, params...))
}

func Query{{title .Name}}s(query string, params []interface{}, lvl int, ctx SQLContext) ([]*{{.Name}}, error) {
	rows, err := ctx.Query(query, params...)
	if err != nil {
		return []*{{.Name}}{}, err
	}
	return Load{{title .Name}}s(rows)
}

func {{$.Visibility}}oad{{title .Name}}(r *sql.Row) (*{{.Name}}, error) {
	var s {{.Name}}
	if err := r.Scan({{range .Fields}}
		&s.{{.Name}},{{end}}
	); err != nil {
		return nil, err
	}
	return &s, nil
}

func {{$.Visibility}}oad{{title .Name}}s(rs *sql.Rows) ([]*{{.Name}}, error) {
	structs := make([]*{{.Name}}, 0, 16)
	var err error
	for rs.Next() {
		var s {{.Name}}
		if err = rs.Scan({{range .Fields}}
			&s.{{.Name}},{{end}}
		); err != nil {
			return nil, err
		}
		structs = append(structs, &s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}
{{end}}
{{end}}{{end}}
