{{define "main"}}// DON'T EDIT *** generated by ormgen *** DON'T EDIT //
package {{.PackageName}}

{{$proto := eq $.Etype "proto"}}
import (
	"database/sql"
	"github.com/lib/pq" {{if $proto}}
	"gitlab.com/astrotit/registration-api/uuid" {{else}}
	"github.com/satori/go.uuid"{{end}}
	"strings"
	"time"
	"fmt"
	"log"
)

func checkSqlUUIDValue(v interface{}) uuid.UUID {
	val := v.(*uuid.NullUUID)
	if !val.Valid{
		return uuid.UUID{}	
	}
	return val.UUID
} 

func checkSqlInt64Value(v interface{}) int64 {
	val := v.(*sql.NullInt64)
	if !val.Valid {
		return 0
	}
	return val.Int64
}

func checkSqlStringValue(v interface{}) string {
	val := v.(*sql.NullString)
	if !val.Valid {
		return ""
	}
	return val.String
}

func checkSqlBoolValue(v interface{}) bool {
	val := v.(*sql.NullBool)
	if !val.Valid {
		return false
	}
	return val.Bool
}

func checkSqlTimeValue(v interface{}) time.Time {
	val := v.(*pq.NullTime)
	if !val.Valid {
		return time.Time{}
	}
	return val.Time
}

func hasWhere(query string) bool {
	if strings.Contains(query, "WHERE") {
		return true
	}
	return false
}

func addPlaceholders(query string, params []interface{}) string {
	swapin := make([]interface{}, len(params))
	for k, _ := range params {
		swapin[k] = k+1
	}
	return fmt.Sprintf(query, swapin...)
}

type Query interface {
	GetQuery() string
	GetParams() []interface{}
	GetDepth() int
}

{{$level := .Level}}
{{$levels := .Levels}}

{{range .Tokens}}

//postgresql specific shit
func {{.Name}}LastInsertID(ctx SQLContext) (int64, error) {
       	var nId int64
       	if err := ctx.QueryRow("select currval('{{tolower .Table}}_{{tolower .IDColumn}}_seq')").Scan(&nId); err != nil {
               	return 0, err
       	}
       	return nId, nil
}

type proxy{{.Name}} struct {
	*{{.Name}}{{range .RootRelations}}
	proxy{{.Field}} *proxy{{.Type}}{{end}}{{range proxysubrels .Name}}
	proxy{{.Field}} *proxy{{.Type}}{{end}}
}

func newProxy{{.Name}} () *proxy{{.Name}} {
	return &proxy{{.Name}}{ {{.Name}}:new({{.Name}})}
}

type {{.Name}}Query struct {
	depth int
	query string
	params []interface{}
}

func(q *{{.Name}}Query) GetQuery() string {
	return addPlaceholders(strings.Replace(q.query, "$p", "$%d", -1), q.params)
}

func(q *{{.Name}}Query) GetParams() []interface{} {
	return q.params
}

func(q *{{.Name}}Query) GetDepth() int {
	return q.depth
}

func(q *{{.Name}}Query) Transform(t func(string)string) *{{.Name}}Query {
	q.query = t(q.query)
	return q
}

func New{{.Name}}Query(lvl int) *{{.Name}}Query {
	return &{{.Name}}Query{
			query:fmt.Sprintf("%s %s", {{.Name}}Select(lvl), {{.Name}}From(lvl)), 
			params:make([]interface{}, 0),
			depth: lvl,
		}
}

func (q *{{.Name}}Query) AddParams(value []interface{}) *{{.Name}}Query {
	q.params = append(q.params, value...)
	return q
}

//TODO add where in
func (q *{{.Name}}Query) Where(prop, operator string, value interface{}) *{{.Name}}Query {
	q.params = append(q.params, value)
	q.query = fmt.Sprintf("%s WHERE %s %s $p", q.query, {{.Name}}PropToSql[prop], operator)
	return q
}

func (q *{{.Name}}Query) And(prop, operator string, value interface{}) *{{.Name}}Query {
	if w := hasWhere(q.query); !w {
		log.Fatalf("using AND without WHERE clause")
	}
	q.params = append(q.params, value)
	q.query = fmt.Sprintf("%s AND %s %s $p", q.query, {{.Name}}PropToSql[prop], operator)
	return q
}

func (q *{{.Name}}Query) Or(prop string, operator string, value interface{}) *{{.Name}}Query {
	if w := hasWhere(q.query); !w {
		log.Fatalf("using OR without WHERE clause")
	}
	q.params = append(q.params, value)
	q.query = fmt.Sprintf("%s OR %s %s $p", q.query, {{.Name}}PropToSql[prop], operator)
	return q
}

//TODO allow multiple columns to sort on
func (q *{{.Name}}Query) OrderBy(prop, dir string) *{{.Name}}Query {
	q.query = fmt.Sprintf("%s ORDER BY %s %s", q.query, {{.Name}}PropToSql[prop], dir)
	return q
}

func (q *{{.Name}}Query) KeyUp(prop string, start, limit int) *{{.Name}}Query {
	q.params = append([]interface{}{limit}, q.params...)
	q.query = strings.Replace(q.query, "FROM {{tolower .Table}}", "FROM (SELECT * FROM {{tolower .Table}} LIMIT $p) AS", 1)
	if start > 0 {
		q.params = append(q.params, start)
		if w := hasWhere(q.query); w {
			q = q.Where(prop, ">", start)
		} else {
			q = q.And(prop, ">", start)
		}
	}
	q = q.OrderBy(prop, "ASC")
	return q
}

func (q *{{.Name}}Query) KeyDown(prop string, start, limit int) *{{.Name}}Query {
	q.params = append([]interface{}{limit}, q.params...)
	q.params = append([]interface{}{start}, q.params...)
	sqlProp := {{.Name}}PropToSql[prop]
	props := strings.Split(sqlProp, ".")
	p := props[len(props)-1]
	q.query = strings.Replace(q.query, "FROM {{tolower .Table}}", "FROM (SELECT * FROM {{tolower .Table}} limited WHERE limited.%[1]s < $p ORDER BY limited.%[1]s DESC LIMIT $p) AS", 1)
	q.query = fmt.Sprintf(q.query, p)
	q.query = fmt.Sprintf(`SELECT t.* FROM ( %s ) AS t ORDER BY t.%s ASC`, 
			q.query, p)
	return q	
}

func (q *{{.Name}}Query) Execute(ctx SQLContext) ([]*{{.Name}}, error) {
	q.query = strings.Replace(q.query, "$p", "$%d", -1)
	q.query = addPlaceholders(q.query, q.params)
	return Query{{title .Name}}s(q.query, q.params, q.depth, ctx)
}

func (q *{{.Name}}Query) Single(ctx SQLContext) (*{{.Name}}, error) {
	q.query = strings.Replace(q.query, "$p", "$%d", -1)
	q.query = addPlaceholders(q.query, q.params)
	return Query{{title .Name}}(q.query, q.params, q.depth, ctx)
}

func Find{{title .Name}}ByID(id {{.IDType}}, lvl int, ctx SQLContext) (*{{.Name}}, error) {
        return New{{.Name}}Query(lvl).Where("ID", "=", id).Single(ctx)
}

{{/*{{if not .LinkEntity}}*/}}
func Delete{{title .Name}}(entity *{{.Name}}, ctx SQLContext) (err error) {
	if entity.ID == {{if eq .IDType "int64"}}0{{else if eq .IDType "uuid.UUID"}}uuid.Nil{{else}}nil{{end}} {
		return fmt.Errorf("Cannot delete without entity identifier %s on %s", "Delete", "{{.Name}}")
	}
	_, err = ctx.Exec("DELETE FROM {{.Table}} WHERE {{.IDColumn}} = $1", entity.ID)
	return
}
{{/*{{else}}//hack - need to check if this is a good permanent solution and not only for this schema
func Delete{{title .Name}}(entity *{{.Name}}, ctx SQLContext) (err error) { {{$natfields := ffilternatid .Fields}}
	queryWhere := `WHERE {{range $fi, $fld := $natfields}}{{if $fi}} AND {{end}}{{.Column}} = ${{plus1 $fi}}{{end}}`
	query := "DELETE FROM {{.Table}} " + queryWhere
	_, err = ctx.Exec(query, {{range $fi, $fld := $natfields}}{{if $fi}}, {{end}}entity.{{.Name}}{{end}})
	return
}
{{end}}*/}}
{{ if .Composite}}

type {{title .Name}}Loader func(*sql.Rows) ([]*{{.Name}}, error)

type Single{{title .Name}}Loader func(*sql.Rows) (*{{.Name}}, error)

var {{.Name}}Loaders map[int]{{.Name}}Loader = map[int]{{.Name}}Loader{ {{$name := .Name}}{{range $lvl, $irrel := $levels}}
	{{$lvl}}:{{$.Visibility}}oad{{title $name}}s_lvl{{itoa $lvl}},{{end}}
}

var Single{{.Name}}Loaders map[int]Single{{.Name}}Loader = map[int]Single{{.Name}}Loader{ {{$name := .Name}}{{range $lvl, $irrel := $levels}}
	{{$lvl}}:{{$.Visibility}}oad{{title $name}}_lvl{{itoa $lvl}},{{end}}
}

func Query{{title .Name}}s(query string, params []interface{}, lvl int, ctx SQLContext) ([]*{{.Name}}, error) {
	rows, err := ctx.Query(query, params...)
	if err != nil {
		return []*{{.Name}}{}, err
	}
	return {{.Name}}Loaders[lvl](rows)
}

func Query{{title .Name}}(query string, params []interface{}, lvl int, ctx SQLContext) (*{{.Name}}, error) {
	rows, err := ctx.Query(query, params...)
	if err != nil {
		return nil, err
	}
	return Single{{.Name}}Loaders[lvl](rows)
}

var {{.Name}}Selects map[int]func()string = map[int]func()string{ {{$name := .Name}}{{range $lvl, $irrel := $levels}}
	{{$lvl}}:{{title $name}}Select_lvl{{itoa $lvl}},{{end}}
}

func {{.Name}}Select(lvl int) string {
	return {{.Name}}Selects[lvl]()
}

var {{.Name}}Froms map[int]func()string = map[int]func()string{ {{$name := .Name}}{{range $lvl, $irrel := $levels}}
	{{$lvl}}:{{title $name}}From_lvl{{itoa $lvl}},{{end}}
}

func {{.Name}}From(lvl int) string {
	return {{.Name}}Froms[lvl]()
}

func Insert{{title .Name}}(entity *{{.Name}}, ctx SQLContext) (err error) {
	err = insert{{title .Name}}(entity, ctx, "")
	return
}

func Upsert{{title .Name}}(entity *{{.Name}}, ctx SQLContext, on string) (err error) {
	err = insert{{title .Name}}(entity, ctx, on)
	return
}

func insert{{title .Name}}(entity *{{.Name}}, ctx SQLContext, on string) (err error) { {{$sfields := .Fields}} {{$owner := .Name}}{{$relations := .Relations}}{{$natfields := ffiltersliceandid .Fields}}
	var query string
	values := make([]interface{}, 0){{range $natfields}}{{if isreference .}}
	if entity.{{referenceonly .Name}} == nil {
		values = append(values, nil)
	} else {
		values = append(values, entity.{{.Name}})
	}{{else}}
	values = append(values, entity.{{.Name}}){{end}}{{end}}
	if len(values) == 0 {
		query = `INSERT INTO {{.Table}} DEFAULT VALUES`
	} else if entity.ID == {{if eq "uuid.UUID" (lookupidtype .Name)}}uuid.Nil{{else}}0{{end}} {
		query = `INSERT INTO {{.Table}} ({{range $fi, $fld := $natfields}}{{if $fi}}, {{end}}{{switch2fk .}}{{end}}) VALUES({{range $idx, $fldx := $natfields}}{{if $idx}}, {{end}}${{plus1 $idx}}{{end}})`
	} else {
		values = append([]interface{}{entity.ID}, values...)
		query = `INSERT INTO {{.Table}} ({{.IDColumn}}, {{range $fi, $fld := $natfields}}{{if $fi}}, {{end}}{{switch2fk .}}{{end}}) VALUES($1, {{range $idx, $fldx := $natfields}}{{if $idx}}, {{end}}${{plus2 $idx}}{{end}})`
	}
	if on != "" {
		query = fmt.Sprintf("%s ON CONFLICT %s", query, on)
	}
	_, err = ctx.Exec(query, values...)
	return
}

func Update{{title .Name}}(entity *{{.Name}}, ctx SQLContext) (err error) { {{$natfields := ffiltersliceandid .Fields}}
	if entity.ID == {{if eq .IDType "uuid.UUID"}}uuid.Nil{{else}}0{{end}} {
		return fmt.Errorf("Cannot update without entity identifier %s on %s", "Update", "{{.Name}}")
	}{{$l := len $natfields}}
	queryPrts := make([]string, 0)
	updateFields := make([]interface{}, 0){{range $fi, $fld := $natfields}}{{if isreference .}}
	if entity.{{referenceonly .Name}} == nil || entity.{{.Name}} == {{if eq .Type "uuid.UUID"}}uuid.Nil{{else}}0{{end}} {
		updateFields = append(updateFields, nil)
	} else {
		updateFields = append(updateFields, entity.{{.Name}})
	}{{else}}
	updateFields = append(updateFields, entity.{{.Name}}){{end}}
	queryPrts = append(queryPrts, `{{switch2fk .}} = ${{plus1 $fi}}`){{end}}
	//queryStr := strings.Join(queryPrts, ", ") + ` WHERE {{.IDColumn}} = ${{plus1 $l}}`
	queryStr := fmt.Sprintf("SET %s WHERE {{.IDColumn}} = ${{plus1 $l}}", strings.Join(queryPrts, ", "))
	updateFields = append(updateFields, entity.ID)
	query := `UPDATE {{.Table}} ` + queryStr
	_, err = ctx.Exec(query, updateFields...)
	return
}
{{else}}

func {{.Name}}From(lvl int) string { {{$basetpe := .Name}}
	return `FROM {{.Table}} {{.Alias}}`
}

func {{.Name}}Select(lvl int) string { {{$tok := .}}
	return `SELECT {{range $fi, $fld := .Fields}}{{if $fi}}, {{end}}{{updatealias $tok . .Alias}}.{{.Column}}{{end}}`
}

{{if ne .IDType ""}}
func Update{{title .Name}}(entity *{{.Name}}, ctx SQLContext) (err error) { {{$natfields := ffiltersliceandid .Fields}}
	if entity.ID == {{if eq .IDType "uuid.UUID"}}uuid.Nil{{else}}0{{end}} {
		return fmt.Errorf("Cannot update without entity identifier %s on %s", "Update", "{{.Name}}")
	}{{$l := len $natfields}}
	queryPrts := make([]string, 0)
	updateFields := make([]interface{}, 0){{range $fi, $fld := $natfields}}
	updateFields = append(updateFields, entity.{{.Name}})
	queryPrts = append(queryPrts, `{{switch2fk .}} = ${{plus1 $fi}}`){{end}}
	//queryStr := strings.Join(queryPrts, ", ") + ` WHERE {{.IDColumn}} = ${{plus1 $l}}`
	queryStr := fmt.Sprintf("SET %s WHERE {{.IDColumn}} = ${{plus1 $l}}", strings.Join(queryPrts, ", "))
	updateFields = append(updateFields, entity.ID)
	_, err = ctx.Exec(`UPDATE {{.Table}} ` + queryStr, updateFields...)
	return
}
{{end}}


func Insert{{title .Name}}(entity *{{.Name}}, ctx SQLContext) (err error) { {{$natfields := ffilternatid .Fields}} {{$uuid := eq .IDType "uuid.UUID"}}
query := `INSERT INTO {{.Table}} ({{if $uuid}}{{.IDColumn}}, {{end}}{{range $fi, $fld := $natfields}}{{if $fi}}, {{end}}{{.Column}}{{end}}) VALUES({{if $uuid}}$1, {{end}}{{range $idx, $fldx := $natfields}}{{if $idx}}, {{end}}${{if $uuid}}{{plus2 $idx}}{{else}}{{plus1 $idx}}{{end}}{{end}})`
	_, err = ctx.Exec(query, {{if $uuid}}entity.ID, {{end}}{{range $fi, $fld := $natfields}}{{if $fi}}, {{end}}entity.{{.Name}}{{end}})
	return
}

func Query{{title .Name}}(query string, params []interface{}, lvl int, ctx SQLContext) (*{{.Name}}, error) {
	return Load{{title .Name}}(ctx.QueryRow(query, params...))
}

func Query{{title .Name}}s(query string, params []interface{}, lvl int, ctx SQLContext) ([]*{{.Name}}, error) {
	rows, err := ctx.Query(query, params...)
	if err != nil {
		return []*{{.Name}}{}, err
	}
	return Load{{title .Name}}s(rows)
}

func {{$.Visibility}}oad{{title .Name}}(r *sql.Row) (*{{.Name}}, error) {
	var s {{.Name}}
	if err := r.Scan({{range .Fields}}
		&s.{{.Name}},{{end}}
	); err != nil {
		return nil, err
	}
	return &s, nil
}

func {{$.Visibility}}oad{{title .Name}}s(rs *sql.Rows) ([]*{{.Name}}, error) {
	structs := make([]*{{.Name}}, 0, 16)
	var err error
	for rs.Next() {
		var s {{.Name}}
		if err = rs.Scan({{range .Fields}}
			&s.{{.Name}},{{end}}
		); err != nil {
			return nil, err
		}
		structs = append(structs, &s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}
{{end}}
{{end}}{{end}}
