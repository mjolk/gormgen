{{define "scans"}}// DON'T EDIT *** generated by scaneo *** DON'T EDIT //

package {{.PackageName}}

import (
	"database/sql"
	"errors"
	"log"
	"strings"
)

{{range .Tokens}}

func Query{{title .Name}}s(query string, params []interface{}) ([]*{{.Name}}, error) {
	rows, err := Dbase().Query(query, params...)
	if err != nil {
		log.Fatal(err)
	}
	return Load{{title .Name}}s(rows)
}

func {{.Name}}From() string {
	return `FROM {{.Table}} {{.Alias}}{{$mt:=.Alias}}{{range .OneToMany}} LEFT JOIN {{.Table}} {{.Alias}} ON {{$mt}}.{{.From}} = {{.Alias}}.{{.To}}{{end}}{{range .ManyToOne}} LEFT JOIN {{.Table}} {{.Alias}} ON {{$mt}}.{{.From}} = {{.Alias}}.{{.To}}{{end}}{{range .ManyToMany}} LEFT JOIN {{.LinkTable}} {{.LinkAlias}} ON {{$mt}}.{{.From}} = {{.LinkAlias}}.{{.To}} LEFT JOIN {{.Table}} {{.Alias}} ON {{.LinkAlias}}.{{.LinkFrom}} = {{.Alias}}.{{.LinkTo}}{{end}}`
}

func {{.Name}}Select() string { {{$tok := .}}
	return `SELECT {{range $fi, $fld := .Fields}}{{if $fi}}, {{end}}{{updatealias $tok .Name .Alias}}.{{.Column}}{{end}}`
}

func Find{{title .Name}}ByID(id int) (*{{.Name}}, error) {
        query := {{.Name}}Select() + " " + {{.Name}}From() + " " + "WHERE {{.Alias}}.{{.IdColumn}} = $1"
	return Query{{title .Name}}(query, []interface{}{id})
}
{{ if .Composite}}
func Insert{{title .Name}}(entity *{{.Name}}) (err error) {
	return Transact(func (tx *sql.Tx) error {  {{$natfields := ffiltersliceandid .Fields}}
		_, err = Dbase().Exec(`INSERT INTO {{.Table}} ({{range $fi, $fld := $natfields}}{{if $fi}}, {{end}}{{switch2fk .}}{{end}}) VALUES({{range $idx, $fldx := $natfields}}{{if $idx}}, {{end}}${{plus1 $idx}}{{end}})`, {{range $fi, $fld := $natfields}}{{if $fi}}, {{end}}entity.{{.Name}}{{end}}){{$fields:=.Fields}}{{range .OneToMany}}{{$tpe:=.Field}}{{$aliasOm:=.Alias}}
		if len(entity.{{.Field}}) > 0 {
			for _, rel := range entity.{{.Field}} {
				_, err = Dbase().Exec(`INSERT INTO {{.Table}}{{$filtered := ffilterid $fields $tpe}}({{range $fin, $flde := $filtered}}{{if $fin}}, {{end}} {{$flde.Column}}{{end}})
			       VALUES({{range $finx, $fldex := $filtered}}{{if $finx}}, {{end}}${{plus1 $finx}}{{end}})`, 
			        {{range $finxx, $fldexx := $filtered}}{{if $finxx}}, {{end}}rel.{{field .Name}}{{end}})
			}
		}{{end}}{{range .ManyToMany}}
		if len(entity.{{.Field}}) > 0 {
			for _, rel := range entity.{{.Field}} {
				_, err = Dbase().Exec(`INSERT INTO {{.LinkTable}} ({{.To}}, {{.LinkFrom}}) VALUES($1, $2)`, entity.ID, rel.ID) 
			}
		}{{end}}
		return err
        })
}

func Update{{title .Name}}(entity *{{.Name}}) (err error) { {{$natfields := ffiltersliceandid .Fields}}
	if entity.ID == 0 {
		return errors.New("Cannot update without entity identifier")
	}
	return Transact(func (*sql.Tx) error { {{$l := len $natfields}}
		queryPrts := make([]string, 0)
		updateFields := make([]interface{}, 0)
		{{range $fi, $fld := $natfields}}{{$isbool := isbool .Type}}{{if not $isbool}}if entity.{{.Name}} != {{if isint .Type}}0{{else if isstring .Type}}""{{else}}nil{{end}} {
			queryPrts = append(queryPrts, `SET {{switch2fk .}} = ${{plus1 $fi}}`)
			updateFields = append(updateFields, entity.{{.Name}})
		}{{else}}
		queryPrts = append(queryPrts, `SET {{.Column}} = ${{plus1 $fi}}`)
		updateFields = append(updateFields, entity.{{.Name}}){{end}}
		{{end}}
		queryStr := strings.Join(queryPrts, ", ") + ` WHERE {{.IdColumn}} = ${{plus1 $l}}`
		updateFields = append(updateFields, entity.ID)
		_, err := Dbase().Exec(`UPDATE {{.Table}} ` + queryStr, updateFields...)
		return err
	})
}

func Query{{title .Name}}(query string, params []interface{}) (*{{.Name}}, error) {
	rows, err := Dbase().Query(query, params...)
	if err != nil {
		log.Fatal(err)
	}
	return Load{{title .Name}}(rows)
}

type proxy{{.Name}} struct {
	*{{.Name}}{{range .OneToMany}}
	proxy{{.Field}} *{{.Type}}{{end}}{{range .ManyToMany}}
        proxy{{.Field}} *{{.Type}}
	proxy{{.LinkField}} *{{.LinkType}}{{end}}
}

func {{$.Visibility}}oad{{title .Name}}(rs *sql.Rows) (*{{.Name}}, error) {
	result, err := {{$.Visibility}}oad{{title .Name}}s(rs)
	if err != nil {
		return nil, err
	}
	if len(result) > 1 {
		return nil, errors.New("More than one result") 
	}
	return result[0], nil
}

func {{$.Visibility}}oad{{title .Name}}s(rs *sql.Rows) ([]*{{.Name}}, error) {
	var err error
	result := make([]*{{.Name}}, 25)
	for rs.Next() {
		s := proxy{{.Name}}{ {{.Name}}:&{{.Name}}{ {{range $i, $f := .ManyToOne}}{{if $i}}, {{end}}{{.Field}}:&{{.Type}}{}{{end}} },{{$om := len .OneToMany}}{{range $j, $k := .OneToMany}}{{if $j}}, {{end}}proxy{{.Field}}:&{{.Type}}{}{{end}}{{if gt $om 0}},{{end}}{{$mm := len .ManyToMany}}{{range $l, $m := .ManyToMany}}{{if $l}}, {{end}}proxy{{.Field}}:&{{.Type}}{}, proxy{{.LinkField}}:&{{.LinkType}}{}{{end}}{{if gt $mm 0}},{{end}}
		}
		if err = rs.Scan({{range .Fields}}
			&s.{{.Name}},{{end}}
		); err != nil {
			return nil, err
		}
		entity := s.{{.Name}}
		var newID bool = true
		for _, ent := range result {
			if ent.ID == s.ID {
				entity = ent
				newID = false
			}
		}
		{{$fields:=.Fields}}{{range .OneToMany}}{{.Field}}Exists := false
		if s.proxy{{.Field}}.ID != 0 {
			if len(entity.{{.Field}}) > 0 {
				for _, rel := range entity.{{.Field}} {
					if rel.ID == s.proxy{{.Field}}.ID {
						{{.Field}}Exists = true
					}
				}
			}
			if !{{.Field}}Exists {
				{{$i:=.Field}}new{{.Type}} := &{{.Type}}{
					{{range $fields}}{{$prox:=proxy .Name}}{{if eq $prox $i}}{{field .Name}}: s.proxy{{$i}}.{{field .Name}},{{end}}{{end}}
				}
				entity.{{.Field}} = append(entity.{{.Field}}, new{{.Type}})
			}
		}{{end}}{{range .ManyToMany}}
		{{.Field}}Exists := false
		if s.proxy{{.Field}}.ID != 0 {
			if len(entity.{{.Field}}) > 0 {
				for _, rel := range entity.{{.Field}} {
					if rel.ID == s.proxy{{.Field}}.ID {
						{{.Field}}Exists = true	
					}	
				}
			}
			if !{{.Field}}Exists { {{$filtrd := ffilter $fields .Field}}{{$mmf := .Field}}{{$lfilterd := ffilter $fields .LinkField}}{{$lmf := .LinkField}}
				new{{.Type}} := &{{.Type}}{
					{{range $a, $b := $filtrd}}{{if $a}}, {{end}}{{field .Name}}: s.proxy{{$mmf}}.{{field .Name}}{{end}},
					{{range $c, $d := $lfilterd}}{{if $c}}, {{end}}{{field .Name}}: s.proxy{{$lmf}}.{{field .Name}}{{end}},
				}
				entity.{{.Field}} = append(entity.{{.Field}}, new{{.Type}})
			}
		}
		{{end}}if newID {
			result = append(result, entity)
		}
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return result, nil
}
{{else}}
func Insert{{title .Name}}(entity *{{.Name}}) (err error) { {{$natfields := ffilternatid .Fields}}
	_, err = Dbase().Exec(`INSERT INTO {{.Table}} ({{range $fi, $fld := $natfields}}{{if $fi}}, {{end}}{{.Column}}{{end}}) VALUES({{range $idx, $fldx := $natfields}}{{if $idx}}, {{end}}${{plus1 $idx}}{{end}})`, {{range $fi, $fld := $natfields}}{{if $fi}}, {{end}}entity.{{.Name}}{{end}})
	return err
}

func Query{{title .Name}}(query string, params []interface{}) (*{{.Name}}, error) {
	row := Dbase().QueryRow(query, params...)
	return Load{{title .Name}}(row)
}

func {{$.Visibility}}oad{{title .Name}}(r *sql.Row) (*{{.Name}}, error) {
	var s {{.Name}}
	if err := r.Scan({{range .Fields}}
		&s.{{.Name}},{{end}}
	); err != nil {
		return nil, err
	}
	return &s, nil
}

func {{$.Visibility}}oad{{title .Name}}s(rs *sql.Rows) ([]*{{.Name}}, error) {
	structs := make([]*{{.Name}}, 0, 16)
	var err error
	for rs.Next() {
		var s {{.Name}}
		if err = rs.Scan({{range .Fields}}
			&s.{{.Name}},{{end}}
		); err != nil {
			return nil, err
		}
		structs = append(structs, &s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

{{end}}{{end}}
{{end}}
