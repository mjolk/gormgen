{{define "main"}}// DON'T EDIT *** generated by ormgen *** DON'T EDIT //
package {{.PackageName}}

{{$proto := eq $.Etype "proto"}}
{{$psql := psql $.Dialect}}
{{$mysql := msql $.Dialect}}
{{$csql := csql $.Dialect}}
import (
	"database/sql" {{if or $csql $psql}}
	"github.com/lib/pq" {{else}}
	"github.com/go-sql-driver/mysql"{{end}}{{if $proto}}
	"gitlab.com/astrotit/registration-api/uuid" {{else}}
	"github.com/gofrs/uuid"{{end}}
	"strings"
	"time"
	"fmt"
	"log"
)

func checkSqlUUIDValue(v interface{}) uuid.UUID {
	val := v.(*uuid.NullUUID)
	if !val.Valid{
		return uuid.UUID{}	
	}
	return val.UUID
} 

func checkSqlInt64Value(v interface{}) int64 {
	val := v.(*sql.NullInt64)
	if !val.Valid {
		return 0
	}
	return val.Int64
}

func checkSqlStringValue(v interface{}) string {
	val := v.(*sql.NullString)
	if !val.Valid {
		return ""
	}
	return val.String
}

func checkSqlBoolValue(v interface{}) bool {
	val := v.(*sql.NullBool)
	if !val.Valid {
		return false
	}
	return val.Bool
}

func checkSqlTimeValue(v interface{}) time.Time {
	val := v.({{if or $psql $csql}}*pq.NullTime{{else}}*mysql.NullTime{{end}})
	if !val.Valid {
		return time.Time{}
	}
	return val.Time
}

func hasWhere(query string) bool {
	if strings.Contains(query, "WHERE") {
		return true
	}
	return false
}

func addPlaceholders(query string, params []interface{}) string {
	swapin := make([]interface{}, len(params))
	for k, _ := range params {
		swapin[k] = k+1
	}
	return fmt.Sprintf(query, swapin...)
}

type Query interface {
	GetQuery() string
	GetParams() []interface{}
	GetDepth() int
}

{{$level := .Level}}
{{$levels := .Levels}}

{{range .Tokens}}
type proxy{{.Name}} struct {
	*{{.Name}}{{range .RootRelations}}
	proxy{{.Field}} *proxy{{.Type}}{{end}}{{range proxysubrels .Name}}
	proxy{{.Field}} *proxy{{.Type}}{{end}}
}

func newProxy{{.Name}} () *proxy{{.Name}} {
	return &proxy{{.Name}}{ {{.Name}}:new({{.Name}})}
}

type {{.Name}}Query struct {
	depth int
	query string
	params []interface{}
}

func(q *{{.Name}}Query) GetQuery() string {
	return addPlaceholders(strings.Replace(q.query, "$p", "$%d", -1), q.params)
}

func(q *{{.Name}}Query) GetParams() []interface{} {
	return q.params
}

func(q *{{.Name}}Query) GetDepth() int {
	return q.depth
}

func(q *{{.Name}}Query) Transform(t func(string)string) *{{.Name}}Query {
	q.query = t(q.query)
	return q
}

func New{{.Name}}Query(lvl int) *{{.Name}}Query {
	return &{{.Name}}Query{
			query:fmt.Sprintf("%s %s", {{.Name}}Select(lvl), {{.Name}}From(lvl)), 
			params:make([]interface{}, 0),
			depth: lvl,
		}
}

func Delete{{.Name}}Query(lvl int) *{{.Name}}Query {
	return &{{.Name}}Query{
		query:fmt.Sprintf("DELETE %s", {{.Name}}From(lvl)),
		params:make([]interface{}, 0),
		depth: lvl,
		}
}

func (q *{{.Name}}Query) AddParams(value []interface{}) *{{.Name}}Query {
	q.params = append(q.params, value...)
	return q
}

//TODO add where in
func (q *{{.Name}}Query) Where(prop, operator string, value interface{}) *{{.Name}}Query {
	q.params = append(q.params, value)
	q.query = fmt.Sprintf("%s WHERE %s %s $p", q.query, {{.Name}}PropToSql[prop], operator)
	return q
}

func (q *{{.Name}}Query) And(prop, operator string, value interface{}) *{{.Name}}Query {
	if w := hasWhere(q.query); !w {
		log.Fatalf("using AND without WHERE clause")
	}
	q.params = append(q.params, value)
	q.query = fmt.Sprintf("%s AND %s %s $p", q.query, {{.Name}}PropToSql[prop], operator)
	return q
}

func (q *{{.Name}}Query) Or(prop string, operator string, value interface{}) *{{.Name}}Query {
	if w := hasWhere(q.query); !w {
		log.Fatalf("using OR without WHERE clause")
	}
	q.params = append(q.params, value)
	q.query = fmt.Sprintf("%s OR %s %s $p", q.query, {{.Name}}PropToSql[prop], operator)
	return q
}

//TODO allow multiple columns to sort on
func (q *{{.Name}}Query) OrderBy(prop, dir string) *{{.Name}}Query {
	q.query = fmt.Sprintf("%s ORDER BY %s %s", q.query, {{.Name}}PropToSql[prop], dir)
	return q
}

func (q *{{.Name}}Query) Limit(count int) *{{.Name}}Query {
	q.params = append(q.params, count)
	q.query = fmt.Sprintf("%s LIMIT $p", q.query)
	return q
}

func (q *{{.Name}}Query) KeyUp(prop string, start, limit int) *{{.Name}}Query {
	q.params = append([]interface{}{limit}, q.params...)
	q.query = strings.Replace(q.query, "FROM {{tolower .Table}}", "FROM (SELECT * FROM {{tolower .Table}} LIMIT $p) AS", 1)
	if start > 0 {
		q.params = append(q.params, start)
		if w := hasWhere(q.query); w {
			q = q.Where(prop, ">", start)
		} else {
			q = q.And(prop, ">", start)
		}
	}
	q = q.OrderBy(prop, "ASC")
	return q
}

func (q *{{.Name}}Query) KeyDown(prop string, start, limit int) *{{.Name}}Query {
	q.params = append([]interface{}{limit}, q.params...)
	q.params = append([]interface{}{start}, q.params...)
	sqlProp := {{.Name}}PropToSql[prop]
	props := strings.Split(sqlProp, ".")
	p := props[len(props)-1]
	q.query = strings.Replace(q.query, "FROM {{tolower .Table}}", "FROM (SELECT * FROM {{tolower .Table}} limited WHERE limited.%[1]s < $p ORDER BY limited.%[1]s DESC LIMIT $p) AS", 1)
	q.query = fmt.Sprintf(q.query, p)
	q.query = fmt.Sprintf(`SELECT t.* FROM ( %s ) AS t ORDER BY t.%s ASC`, 
			q.query, p)
	return q	
}

func (q *{{.Name}}Query) Execute(ctx SQLContext) ([]*{{.Name}}, error) {
	q.query = strings.Replace(q.query, "$p", "$%d", -1)
	q.query = addPlaceholders(q.query, q.params)
	return Query{{title .Name}}s(q.query, q.params, q.depth, ctx)
}

func (q *{{.Name}}Query) Single(ctx SQLContext) (*{{.Name}}, error) {
	q.query = strings.Replace(q.query, "$p", "$%d", -1)
	q.query = addPlaceholders(q.query, q.params)
	return Query{{title .Name}}(q.query, q.params, q.depth, ctx)
}

func Find{{title .Name}}ByID(id {{.IDType}}, lvl int, ctx SQLContext) (*{{.Name}}, error) {
        return New{{.Name}}Query(lvl).Where("ID", "=", id).Single(ctx)
}

{{/*{{if not .LinkEntity}}*/}}
func Delete{{title .Name}}(entity *{{.Name}}, ctx SQLContext) (err error) {
	if entity.ID == {{if eq .IDType "int64"}}0{{else if eq .IDType "uuid.UUID"}}uuid.Nil{{else}}nil{{end}} {
		return fmt.Errorf("Cannot delete without entity identifier %s on %s", "Delete", "{{.Name}}")
	}
	_, err = ctx.Exec("DELETE FROM {{.Table}} WHERE {{.IDColumn}} = $1", entity.ID)
	return
}

func Insert{{title .Name}}(ctx SQLContext, entity ...*{{.Name}}) ([]interface{} , error) {
	return insert{{title .Name}}(ctx, "", entity...)
}

func Upsert{{title .Name}}(ctx SQLContext,  on string, entity ...*{{.Name}}) ([]interface{}, error) {
	return insert{{title .Name}}(ctx, on, entity...)
}


func insert{{title .Name}}(ctx SQLContext, on string, entities ...*{{.Name}}) ([]interface{}, error) { {{$sfields := .Fields}} {{$owner := .Name}}{{$relations := .Relations}}{{$natfields := ffiltersliceandid .Fields}}
	eCount := len(entities)
	returnIds := make([]interface{}, eCount)	
	if eCount == 0 {
		return returnIds, nil
	}
	{{$len := len $natfields}}vQuery := make([]string, eCount)
	values := make([]interface{}, 0)
	for i, entity := range entities {
	tv := make([]interface{}, {{$len}})	{{range $fi, $fld := $natfields}}{{if isreference .}}
	if entity.{{referenceonly .Name}} == nil {
		tv[{{$fi}}] = nil
	} else {
		tv[{{$fi}}] = entity.{{.Name}}
	}{{else}}
	tv[{{$fi}}] = entity.{{.Name}}{{end}}{{end}}
	values = append(values, tv...)
	holders := make([]interface{}, {{$len}})
	for f := 0;f < {{$len}};f++{
		holders[f] = (f+1)+(i*{{$len}})
	}
	vQuery[i] = fmt.Sprintf(`({{range $idx, $fldx := $natfields}}{{if $idx}}, {{end}}$%d{{end}})`, holders...)
	} 
	query := `INSERT INTO {{.Table}}`
	if len(values) == 0 {
		 query = fmt.Sprintf("%s DEFAULT VALUES", query)
	} else {
		query = fmt.Sprintf(`%s ({{range $fi, $fld := $natfields}}{{if $fi}}, {{end}}{{switch2fk .}}{{end}}) VALUES %s`, query, strings.Join(vQuery, ", "))
	}
	if on != "" {
		query = fmt.Sprintf("%s ON CONFLICT %s", query, on)
	}
	{{if or $psql $csql}}query = fmt.Sprintf("%s RETURNING {{.IDColumn}}", query)
	if(eCount == 1){
		if err := ctx.QueryRow(query, values...).Scan(&returnIds[0]); err != nil {
			return returnIds, err
		}
		return returnIds, nil
		
	} else {
		rows, err := ctx.Query(query, values...)
		if err != nil {
			return returnIds, err
		}
		defer rows.Close()
		cnt := 0
		for rows.Next() {
			if err = rows.Scan(&returnIds[cnt]); err != nil {
				return returnIds, err
			}
			cnt++
		}
		if cErr := rows.Close(); cErr != nil {
			return returnIds, cErr
		}
		if err := rows.Err(); err != nil {
			return returnIds, err
		}
	}
	return returnIds, nil
	{{else}}
	return ctx.Exec(query, values...)
	{{end}}
}
{{/*{{else}}//hack - need to check if this is a good permanent solution and not only for this schema
func Delete{{title .Name}}(entity *{{.Name}}, ctx SQLContext) (err error) { {{$natfields := ffilternatid .Fields}}
	queryWhere := `WHERE {{range $fi, $fld := $natfields}}{{if $fi}} AND {{end}}{{.Column}} = ${{plus1 $fi}}{{end}}`
	query := "DELETE FROM {{.Table}} " + queryWhere
	_, err = ctx.Exec(query, {{range $fi, $fld := $natfields}}{{if $fi}}, {{end}}entity.{{.Name}}{{end}})
	return
}
{{end}}*/}}
{{ if .Composite}}

type {{title .Name}}Loader func(*sql.Rows) ([]*{{.Name}}, error)

type Single{{title .Name}}Loader func(*sql.Rows) (*{{.Name}}, error)

var {{.Name}}Loaders map[int]{{.Name}}Loader = map[int]{{.Name}}Loader{ {{$name := .Name}}{{range $lvl, $irrel := $levels}}
	{{$lvl}}:{{$.Visibility}}oad{{title $name}}s_lvl{{itoa $lvl}},{{end}}
}

var Single{{.Name}}Loaders map[int]Single{{.Name}}Loader = map[int]Single{{.Name}}Loader{ {{$name := .Name}}{{range $lvl, $irrel := $levels}}
	{{$lvl}}:{{$.Visibility}}oad{{title $name}}_lvl{{itoa $lvl}},{{end}}
}

func Query{{title .Name}}s(query string, params []interface{}, lvl int, ctx SQLContext) ([]*{{.Name}}, error) {
	rows, err := ctx.Query(query, params...)
	if err != nil {
		return []*{{.Name}}{}, err
	}
	return {{.Name}}Loaders[lvl](rows)
}

func Query{{title .Name}}(query string, params []interface{}, lvl int, ctx SQLContext) (*{{.Name}}, error) {
	rows, err := ctx.Query(query, params...)
	if err != nil {
		return nil, err
	}
	return Single{{.Name}}Loaders[lvl](rows)
}

var {{.Name}}Selects map[int]func()string = map[int]func()string{ {{$name := .Name}}{{range $lvl, $irrel := $levels}}
	{{$lvl}}:{{title $name}}Select_lvl{{itoa $lvl}},{{end}}
}

func {{.Name}}Select(lvl int) string {
	return {{.Name}}Selects[lvl]()
}

var {{.Name}}Froms map[int]func()string = map[int]func()string{ {{$name := .Name}}{{range $lvl, $irrel := $levels}}
	{{$lvl}}:{{title $name}}From_lvl{{itoa $lvl}},{{end}}
}

func {{.Name}}From(lvl int) string {
	return {{.Name}}Froms[lvl]()
}


func Update{{title .Name}}(entity *{{.Name}}, ctx SQLContext) (err error) { {{$natfields := ffiltersliceandid .Fields}}
	if entity.ID == {{if eq .IDType "uuid.UUID"}}uuid.Nil{{else}}0{{end}} {
		return fmt.Errorf("Cannot update without entity identifier %s on %s", "Update", "{{.Name}}")
	}{{$l := len $natfields}}
	queryPrts := make([]string, {{$l}})
	updateFields := make([]interface{}, {{$l}}+1){{range $fi, $fld := $natfields}}{{if isreference .}}
	if entity.{{referenceonly .Name}} == nil || entity.{{.Name}} == {{if eq .Type "uuid.UUID"}}uuid.Nil{{else}}0{{end}} {
		updateFields[{{$fi}}] = nil
	} else {
		updateFields[{{$fi}}] = entity.{{.Name}}
	}{{else}}
	updateFields[{{$fi}}] = entity.{{.Name}}{{end}}
	queryPrts[{{$fi}}] = `{{switch2fk .}} = ${{plus1 $fi}}`{{end}}
	//queryStr := strings.Join(queryPrts, ", ") + ` WHERE {{.IDColumn}} = ${{plus1 $l}}`
	queryStr := fmt.Sprintf("SET %s WHERE {{.IDColumn}} = ${{plus1 $l}}", strings.Join(queryPrts, ", "))
	updateFields[{{$l}}] = entity.ID
	query := `UPDATE {{.Table}} ` + queryStr
	_, err = ctx.Exec(query, updateFields...)
	return
}
{{else}}

func {{.Name}}From(lvl int) string { {{$basetpe := .Name}}
	return `FROM {{.Table}} {{.Alias}}`
}

func {{.Name}}Select(lvl int) string { {{$tok := .}}
	return `SELECT {{range $fi, $fld := .Fields}}{{if $fi}}, {{end}}{{updatealias $tok . .Alias}}.{{.Column}}{{end}}`
}

{{if ne .IDType ""}}
func Update{{title .Name}}(entity *{{.Name}}, ctx SQLContext) (err error) { {{$natfields := ffiltersliceandid .Fields}}
	if entity.ID == {{if eq .IDType "uuid.UUID"}}uuid.Nil{{else}}0{{end}} {
		return fmt.Errorf("Cannot update without entity identifier %s on %s", "Update", "{{.Name}}")
	}{{$l := len $natfields}}
	queryPrts := make([]string, {{$l}})
	updateFields := make([]interface{}, {{$l}}+1){{range $fi, $fld := $natfields}}
	updateFields[{{$fi}}] = entity.{{.Name}}
	queryPrts[{{$fi}}] = `{{switch2fk .}} = ${{plus1 $fi}}`{{end}}
	//queryStr := strings.Join(queryPrts, ", ") + ` WHERE {{.IDColumn}} = ${{plus1 $l}}`
	queryStr := fmt.Sprintf("SET %s WHERE {{.IDColumn}} = ${{plus1 $l}}", strings.Join(queryPrts, ", "))
	updateFields[{{$l}}] = entity.ID
	_, err = ctx.Exec(`UPDATE {{.Table}} ` + queryStr, updateFields...)
	return
}
{{end}}


func Query{{title .Name}}(query string, params []interface{}, lvl int, ctx SQLContext) (*{{.Name}}, error) {
	return Load{{title .Name}}(ctx.QueryRow(query, params...))
}

func Query{{title .Name}}s(query string, params []interface{}, lvl int, ctx SQLContext) ([]*{{.Name}}, error) {
	rows, err := ctx.Query(query, params...)
	if err != nil {
		return []*{{.Name}}{}, err
	}
	return Load{{title .Name}}s(rows)
}

func {{$.Visibility}}oad{{title .Name}}(r *sql.Row) (*{{.Name}}, error) {
	var s {{.Name}}
	if err := r.Scan({{range .Fields}}
		&s.{{.Name}},{{end}}
	); err != nil {
		return nil, err
	}
	return &s, nil
}

func {{$.Visibility}}oad{{title .Name}}s(rs *sql.Rows) ([]*{{.Name}}, error) {
	defer rs.Close()
	structs := make([]*{{.Name}}, 0, 16)
	var err error
	for rs.Next() {
		var s {{.Name}}
		if err = rs.Scan({{range .Fields}}
			&s.{{.Name}},{{end}}
		); err != nil {
			return nil, err
		}
		structs = append(structs, &s)
	}
	if cErr := rs.Close(); cErr != nil {
		return nil, cErr
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}
{{end}}
{{end}}{{end}}
