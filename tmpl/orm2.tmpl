{{define "scans"}}// DON'T EDIT *** generated by ormgen *** DON'T EDIT //

package {{.PackageName}}

import (
	"database/sql"
	"errors"
	"log"
	"strings"
)

{{range .Tokens}}

func Query{{title .Name}}s(query string, params []interface{}) ([]*{{.Name}}, error) {
	rows, err := Dbase().Query(query, params...)
	if err != nil {
		log.Fatal(err)
	}
	return Load{{title .Name}}s(rows)
}

func {{.Name}}From() string { {{$basetpe := .Name}}
	return `FROM {{.Table}} {{.Alias}}{{range .Relations}}{{if .IsOneToMany }} LEFT JOIN {{if .IsAttribute}}(SELECT a.* FROM attribute a INNER JOIN objecttype o ON a.obj_id = o.obj_id WHERE o.name = '{{.ParentName}}' ) AS {{.Alias}} ON {{.ParentAlias}}.{{.From}} = {{.Alias}}.{{.To}}{{else}}{{.Table}} {{.Alias}} ON {{.ParentAlias}}.{{.From}} = {{.Alias}}.{{.To}}{{end}}{{end}}{{if .IsManyToMany}} LEFT JOIN {{.LinkTable}} {{.LinkAlias}} ON {{.ParentAlias}}.{{.From}} = {{.LinkAlias}}.{{.To}} LEFT JOIN {{.Table}} {{.Alias}} ON {{.LinkAlias}}.{{.LinkFrom}} = {{.Alias}}.{{.LinkTo}}{{end}}{{if .IsManyToOne}} LEFT JOIN {{.Table}} {{.Alias}} ON {{.ParentAlias}}.{{.From}} = {{.Alias}}.{{.To}}{{end}}{{end}}`
}

func {{.Name}}Select() string { {{$tok := .}}
	return `SELECT {{range $fi, $fld := .Fields}}{{if $fi}}, {{end}}{{updatealias $tok . .Alias}}.{{.Column}}{{end}}`
}

func Find{{title .Name}}ByID(id int) (*{{.Name}}, error) {
        query := {{.Name}}Select() + " " + {{.Name}}From() + " " + "WHERE {{.Alias}}.{{.IdColumn}} = $1"
	return Query{{title .Name}}(query, []interface{}{id})
}

type proxy{{.Name}} struct {
	*{{.Name}}{{range .RootRelations}}
	proxy{{.Field}} *proxy{{.Type}}{{end}}{{range proxysubrels .Name}}
	proxy{{.Field}} *proxy{{.Type}}{{end}}
}

func newProxy{{.Name}} () *proxy{{.Name}} {
	return &proxy{{.Name}}{ {{.Name}}:new({{.Name}})}
}

{{ if .Composite}}

func Insert{{title .Name}}(entity *{{.Name}}) (err error) { {{$sfields := .Fields}} {{$owner := .Name}}{{$relations := .Relations}}
	{{$natfields := ffiltersliceandid .Fields}}
	_, err = Dbase().Exec(`INSERT INTO {{.Table}} ({{range $fi, $fld := $natfields}}{{if $fi}}, {{end}}{{switch2fk .}}{{end}}) VALUES({{range $idx, $fldx := $natfields}}{{if $idx}}, {{end}}${{plus1 $idx}}{{end}})`, {{range $fi, $fld := $natfields}}{{if $fi}}, {{end}}entity.{{.Name}}{{end}}){{$fields:=.Fields}}{{range .RootRelations}}{{if .IsOneToMany}}
	if len(entity.{{.FieldName}}) > 0 {
		for _, rel := range entity.{{.Field}} {
			err = Insert{{.Type}}(rel)
		}
	}{{end}}{{if .IsManyToMany}}
	if len(entity.{{.Field}}) > 0 {
		for _, rel := range entity.{{.Field}} { {{$natffields := ffilter $sfields .Field}}{{$linktpe := .LinkType}}{{$tolinktpe := .Type}}
			linkEntity := new({{.LinkType}}){{range .SubRelations $relations}}{{if .LinkRelation}}
			linkEntity.{{.Field}} = new({{.Type}}){{end}}{{end}}
		 	linkEntity.{{$owner}}ID = entity.ID
			linkEntity.{{$tolinktpe}}ID = rel.ID {{range $natffields}}{{if .IsLinkField}}
			linkEntity.{{fieldshift .Name}} = rel.{{fieldshift .Name}}{{end}}{{end}}{{range .SubRelations $relations}}{{if .LinkRelation}}
			linkEntity.{{.Type}}.ID = rel.{{.Type}}.ID{{end}}{{end}}
			err = Insert{{.LinkType}}(linkEntity)
		}
	}{{end}}{{end}}
	return err
}

func Update{{title .Name}}(entity *{{.Name}}) (err error) { {{$natfields := ffiltersliceandid .Fields}}
	if entity.ID == 0 {
		return errors.New("Cannot update without entity identifier")
	}
	{{$l := len $natfields}}
	queryPrts := make([]string, 0)
	updateFields := make([]interface{}, 0)
	{{range $fi, $fld := $natfields}}{{$isbool := isbool .Type}}{{if not $isbool}}{{if istime .Type}}if entity.{{.Name}}.IsZero(){{else}}if entity.{{.Name}} != {{if isint .Type}}0{{else if isstring .Type}}""{{else}}nil{{end}}{{end}} {
		queryPrts = append(queryPrts, `SET {{switch2fk .}} = ${{plus1 $fi}}`)
		updateFields = append(updateFields, entity.{{.Name}})
	}{{else}}
	queryPrts = append(queryPrts, `SET {{.Column}} = ${{plus1 $fi}}`)
	updateFields = append(updateFields, entity.{{.Name}}){{end}}
	{{end}}
	queryStr := strings.Join(queryPrts, ", ") + ` WHERE {{.IdColumn}} = ${{plus1 $l}}`
	updateFields = append(updateFields, entity.ID)
	_, err = Dbase().Exec(`UPDATE {{.Table}} ` + queryStr, updateFields...)
	return err
}

func Query{{title .Name}}(query string, params []interface{}) (*{{.Name}}, error) {
	rows, err := Dbase().Query(query, params...)
	if err != nil {
		log.Fatal(err)
	}
	return Load{{title .Name}}(rows)
}

func {{$.Visibility}}oad{{title .Name}}(rs *sql.Rows) (*{{.Name}}, error) {
	result, err := {{$.Visibility}}oad{{title .Name}}s(rs)
	if err != nil {
		return nil, err
	}
	if len(result) > 1 {
		return nil, errors.New("More than one result") 
	}
	return result[0], nil
}

func {{$.Visibility}}oad{{title .Name}}s(rs *sql.Rows) ([]*{{.Name}}, error) {
	var err error
	result := make([]*{{.Name}}, 25)
	for rs.Next() {
		s := newProxy{{.Name}}(){{range .Relations}}
		s.{{.ProxyFieldName}} = {{if .Proxy}}newProxy{{.Type}}(){{else}}new({{.Type}}){{end}}{{end}}
		if err = rs.Scan({{range .Fields}}
			&s.{{.Name}},{{end}}
		); err != nil {
			return nil, err
		}
		entity := s.{{.Name}}
		var newID bool = true
		for _, ent := range result {
			if ent != nil {
				if ent.ID == s.ID {
					entity = ent
					newID = false
				}
			}
		}{{$token := .}}
		{{range .RootRelations}}
		{{template "merge" relarg $token . nil .}}
		{{end}}
                if newID {
			result = append(result, entity)
		}
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return result, nil
}

{{else}}


func Insert{{title .Name}}(entity *{{.Name}}) (err error) { {{$natfields := ffilternatid .Fields}}
	_, err = Dbase().Exec(`INSERT INTO {{.Table}} ({{range $fi, $fld := $natfields}}{{if $fi}}, {{end}}{{.Column}}{{end}}) VALUES({{range $idx, $fldx := $natfields}}{{if $idx}}, {{end}}${{plus1 $idx}}{{end}})`, {{range $fi, $fld := $natfields}}{{if $fi}}, {{end}}entity.{{.Name}}{{end}})
	return err
}

func Query{{title .Name}}(query string, params []interface{}) (*{{.Name}}, error) {
	row := Dbase().QueryRow(query, params...)
	return Load{{title .Name}}(row)
}

func {{$.Visibility}}oad{{title .Name}}(r *sql.Row) (*{{.Name}}, error) {
	var s {{.Name}}
	if err := r.Scan({{range .Fields}}
		&s.{{.Name}},{{end}}
	); err != nil {
		return nil, err
	}
	return &s, nil
}

func {{$.Visibility}}oad{{title .Name}}s(rs *sql.Rows) ([]*{{.Name}}, error) {
	structs := make([]*{{.Name}}, 0, 16)
	var err error
	for rs.Next() {
		var s {{.Name}}
		if err = rs.Scan({{range .Fields}}
			&s.{{.Name}},{{end}}
		); err != nil {
			return nil, err
		}
		structs = append(structs, &s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}
{{end}}
{{end}}{{end}}

{{define "merge"}}
{{$token := .Token}}{{$relation := .Relation}}{{$root := .RootRelation}}{{$fields:= .Token.Fields}}{{$relations := .Token.Relations}}{{if or .Relation.IsOneToMany .Relation.IsManyToMany}}{{tovar .Relation.FieldName}}Exists := false
		if s.{{.Relation.ProxyFieldName}}.ID != 0 { {{$parentlist := listfields .ParentRelation}}
			if len({{if checkparent .ParentRelation}}new{{.ParentRelation.Type}}.{{.Relation.Field}}{{else if ne $parentlist ""}}new{{$parentlist}}.{{.Relation.Field}}{{else}}entity.{{.Relation.FieldName}}{{end}}) > 0 {
				for _, rel := range {{if checkparent .ParentRelation}}new{{.ParentRelation.Type}}.{{.Relation.Field}}{{else if ne $parentlist ""}}new{{$parentlist}}.{{.Relation.Field}}{{else}}entity.{{.Relation.FieldName}}{{end}} {
					if rel.ID == s.{{.Relation.ProxyFieldName}}.ID {
						{{tovar .Relation.FieldName}}Exists = true
					}
				}
			}
			if !{{tovar .Relation.FieldName}}Exists { {{$omfiltrd := norel $fields .Relation.ProxyFieldName}}{{$omntpe := .Relation.Type}}
				new{{.Relation.Type}} := new({{.Relation.Type}}){{$tok := structtok .Relation.Type}}{{range $tok.RootRelations}}{{if .IsManyToOne}}
				new{{$omntpe}}.{{.FieldName}} = new({{.Type}}){{end}}{{end}}
				{{range $a, $b := $omfiltrd}}{{if $a}}
				{{end}}new{{$omntpe}}.{{proxyshift .Name}} = s.{{.Name}}{{end}}{{if .Relation.IsManyToMany}}{{$lfilterd := ffilter $fields .Relation.LinkField}}{{range $c, $d := $lfilterd}}{{if $c}}
				{{end}}newLINK{{$omntpe}}.{{proxyshift .Name}} = s.{{.Name}}{{end}}{{end}}{{end}}
				{{range .Relation.SubRelations .Token.Relations}}{{template "merge" relarg $token . $relation $root}}{{end}}
				{{if or .Relation.IsOneToMany .Relation.IsManyToMany}}{{if .ParentRelation}}{{$parentlist := listfields .ParentRelation}}{{if checkparent .ParentRelation}}new{{.ParentRelation.Type}}.{{.Relation.Field}}{{else if ne $parentlist ""}}new{{$parentlist}}.{{.Relation.Field}}{{else}}entity.{{.Relation.FieldName}}{{end}} = append({{if checkparent .ParentRelation}}new{{.ParentRelation.Type}}.{{.Relation.Field}}{{else if ne $parentlist ""}}new{{$parentlist}}.{{.Relation.Field}}{{else}}entity.{{.Relation.FieldName}}{{end}}, new{{.Relation.Type}}){{else}}
				entity.{{.RootRelation.FieldName}} = append(entity.{{.RootRelation.FieldName}}, new{{.Relation.Type}}){{end}}
			}
		}{{end}}
{{end}}


